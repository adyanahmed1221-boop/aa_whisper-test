ok so i have this app badicly i want u to fix the call add screen sharing add vid calls make the call a diffrent tab and please make it nice here is the app.js // =====================================================================================================================================================================
// aa-whisper
// =====================================================================================================================================================================
// Made by aa using ai
// =====================================================================================================================================================================

document.addEventListener('DOMContentLoaded', function() {
    // ====================================================================================================
    // FIREBASE INITIALIZATION
    // ====================================================================================================
    
    // Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyDju8FmvZmgT6Subk2D7StKW_tzV5oKdao",
        authDomain: "aa-whisper.firebaseapp.com",
        databaseURL: "https://aa-whisper-default-rtdb.firebaseio.com",
        projectId: "aa-whisper",
        storageBucket: "aa-whisper.appspot.com",
        messagingSenderId: "996959903815",
        appId: "1:996959903815:web:065f98c97fa713315d5162",
        measurementId: "G-1HP9YSMHD8"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const database = firebase.database();

    // Initialize Firebase Storage with error handling
    let storage;
    try {
        storage = firebase.storage();
        console.log("üî•‚úîÔ∏è Firebase Storage initialized");
    } catch (error) {
        console.error("üî•‚ùå Firebase Storage initialization failed:", error);
        console.log("Make sure you've included the Firebase Storage script in your HTML");
        
        // Disable image upload UI if Storage is not available
        const uploadElements = [
            'image-upload-btn',
            'image-input',
            'image-preview-container'
        ];
        
        uploadElements.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.style.display = 'none';
            }
        });
    }

    // Set auth persistence
    auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
        .then(() => {
            console.log("üìé‚úîÔ∏è Auth persistence set to LOCAL.");
        })
        .catch((error) => {
            console.error("üìé‚ùå Error setting auth persistence:", error);
        });

    // ====================================================================================================
    // GLOBAL VARIABLES AND STATE MANAGEMENT
    // ====================================================================================================
    
    console.log("%c welcome to whisper! ", 'font-size: 30px; background: linear-gradient(135deg, #1a1a2e, #32264a); border: 1px solid #fff; border-radius: 30px; font-weight: 1000;');
    
    // DOM elements
    const authContainer = document.getElementById('auth-container');
    const appMain = document.getElementById('app-main');
    const guestTab = document.getElementById('guest-tab');
    const accountTab = document.getElementById('account-tab');
    const guestPanel = document.getElementById('guest-panel');
    const accountPanel = document.getElementById('account-panel');
    const signupPanel = document.getElementById('signup-panel');
    const usernamePanel = document.getElementById('username-panel');
    const guestUsername = document.getElementById('guest-username');
    const guestLoginBtn = document.getElementById('guest-login-btn');
    const emailInput = document.getElementById('email');
    const passwordInput = document.getElementById('password');
    const loginBtn = document.getElementById('login-btn');
    const signupEmail = document.getElementById('signup-email');
    const signupPassword = document.getElementById('signup-password');
    const displayName = document.getElementById('display-name');
    const signupBtn = document.getElementById('signup-btn');
    const chooseUsername = document.getElementById('choose-username');
    const setUsernameBtn = document.getElementById('set-username-btn');
    const showSignup = document.getElementById('show-signup');
    const showLogin = document.getElementById('show-login');
    const resetPasswordBtn = document.getElementById('reset-password-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const roomList = document.getElementById('room-list');
    const newRoomName = document.getElementById('new-room-name');
    const userList = document.getElementById('user-list');
    const currentRoomName = document.getElementById('current-room-name');
    const messages = document.getElementById('messages');
    const messageInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
	const recordVoiceBtn = document.getElementById('record-voice-btn');
    const typingIndicator = document.getElementById('typing-indicator');
    const userName = document.getElementById('user-name');
    const userAvatar = document.getElementById('user-avatar');
    const refreshUsersBtn = document.getElementById('refresh-users-btn');
    const recentChatsList = document.getElementById('recent-chats-list');
    const startNewChatBtn = document.getElementById('start-new-chat-btn');
    const newChatModal = document.getElementById('new-chat-modal');
    const closeModalBtn = document.getElementById('close-modal-btn');
    const openNewRoomModalBtn = document.getElementById('open-new-room-modal-btn');
    const newRoomModal = document.getElementById('new-room-modal');
    const closeNewRoomModalBtn = document.getElementById('close-new-room-modal-btn');
    const newRoomNameModal = document.getElementById('new-room-name-modal');
    const newRoomErrorMessage = document.getElementById('new-room-error-message');
    const searchUserInput = document.getElementById('search-user-input');
    const searchResults = document.getElementById('search-results');
    const mobileMenuToggle = document.getElementById('mobile-menu-toggle');
    const sidebar = document.getElementById('sidebar');
    
    // Admin-specific DOM elements
    const adminPanel = document.getElementById('admin-section');
    const banUserBtn = document.getElementById('ban-user-btn');
    const unbanUserBtn = document.getElementById('unban-user-btn');
    const adminUserSelect = document.getElementById('admin-user-select');
    const adminReasonInput = document.getElementById('admin-reason-input');
    const adminActionMessage = document.getElementById('admin-action-message');
    
    // Leader-specific DOM elements
    const grantAdminBtn = document.getElementById('grant-admin-btn');
    const revokeAdminBtn = document.getElementById('revoke-admin-btn')
    
    // Image upload elements
    const imageInput = document.getElementById('image-input');
    const uploadBtn = document.getElementById('image-upload-btn');
    const previewContainer = document.getElementById('image-preview-container');
    const cancelBtn = document.getElementById('cancel-image-btn');
    const imagePreview = document.getElementById('image-preview');
    const imageName = document.getElementById('image-name');
    const imageSize = document.getElementById('image-size');
	
	// Call elements
	const callModal = document.getElementById('call-modal');
	const endCallBtn = document.getElementById('end-call-btn');
	const acceptCallBtn = document.getElementById('accept-call-btn');
	const rejectCallBtn = document.getElementById('reject-call-btn');
	const toggleVideoBtn = document.getElementById('toggle-video-btn');
	const toggleMicBtn = document.getElementById('toggle-mic-btn');
	const callUserName = document.getElementById('call-user-name');
	const callTimer = document.getElementById('call-timer');
    
    // State variables
    let currentUser = null;
    let currentRoom = 'general';
    let isTyping = false;
    let typingTimer = null;
    let privateChatUser = null;
    let heartbeatInterval = null;
    let recentChats = [];
    let collapsedSections = {};
    let allUsers = {};
    let bannedUsers = {};
    let adminUsers = {};
    let messagesRef = null;
    let replyingTo = null;
    let loadingTasks = 0;
    let messagesCallback = null;
    let currentMessagesRef = null;
    let usersValueCallback = null;
    let selectedImage = null;
    let isUploading = false;
	let isRecording = false;
	let mediaRecorder = null;
	let audioChunks = []; 
	let localStream = null;
	let remoteStream = null;
	let localVideo = document.getElementById('local-video');
	let remoteVideo = document.getElementById('remote-video');
	let peerConnection = null;
	let currentCall = null;
	let callTimerInterval = null;
    let isInitialized = false;
	let callStartTime = null;
	let isCallActive = false;
	let incomingCallData = null;


    // ====================================================================================================
    // UTILITY FUNCTIONS
    // ====================================================================================================
    
    // Structured logging helper with optional color-coding
    function log(message, level = 0, feature = null) {
        const indent = '    '.repeat(level);
        let color = 'inherit'; // default color
        let borderLeft = 'transparent'; // default border
        
        // Assign colors based on feature
        if (feature === 'auth') {
            color = '#3498db'; 
            borderLeft = '#3498db', '3px'; // Blue
        }
        if (feature === 'admin') {
            color = '#9b59b6'; 
            borderLeft = '#9b59b6', '3px'; // Purple
        }
        if (feature === 'message') {
            color = '#2ecc71'; 
            borderLeft = '#2ecc71', '3px'; // Green
        }
        if (feature === 'ban') {
            color = '#e74c3c'; 
            borderLeft = '#e74c3c', '3px'; // Red
        }
        if (feature === 'user') {
            color = '#f39c12'; 
            borderLeft = '#f39c12', '3px'; // Orange
        }
        
        // Use %c for styling in the console
        console.log(`%c${indent}${message}`, `color: ${color}; font-weight: bold; border-left: 3px solid ${borderLeft}; padding-left: 5px;`);
    }
    
    // Sound effect for new messages when tab is inactive
    function isTabActive() {
        return !document.hidden;
    }
    
    // Timestamp formatting
    function formatTimestamp(timestamp) {
        if (!timestamp) return 'Unknown';
        
        const date = new Date(timestamp);
        return date.toLocaleString();
    }

    // Simple date format
    function formatShortDate(date) {
        const messageDate = new Date(date);
        const today = new Date();
        
        if (messageDate.toDateString() === today.toDateString()) {
            return 'Today';
        }
        
        return messageDate.toLocaleDateString('en-US', { 
            month: 'short', 
            day: 'numeric' 
        });
    }

    // Format timestamp to readable time
    function formatTime(date) {
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        return `${hours}:${minutes}`;
    }

    // Helper function to set a button's loading state
    function setButtonLoading(buttonElement, isLoading) {
        if (!buttonElement) return; // Added: Null check
        
        if (isLoading) {
            // Save original text and disable the button
            buttonElement.dataset.originalText = buttonElement.textContent;
            buttonElement.disabled = true;
            buttonElement.classList.add('button-loading');
            
            // Clear the button and add the spinner
            buttonElement.innerHTML = '<span class="spinner"></span>';
        } else {
            // Restore the original text and re-enable the button
            buttonElement.disabled = false;
            buttonElement.classList.remove('button-loading');
            buttonElement.textContent = buttonElement.dataset.originalText;
        }
    }

    // Check if current user is an admin
    function isCurrentUserAdmin() {
        return currentUser && (adminUsers[currentUser.uid] || isCurrentUserLeader());
    }

    // Check if current user is a leader
    function isCurrentUserLeader() {
        return currentUser && window.leaderIds && window.leaderIds[currentUser.uid];
    }

    // Check if a user is banned
    function isUserBanned(userId) {
        return bannedUsers[userId];
    }

    // Show admin notification
    function showAdminNotification(message, type = 'info') {
        if (!adminActionMessage) return;
        
        adminActionMessage.textContent = message;
        adminActionMessage.className = `admin-notification ${type}`;
        adminActionMessage.style.display = 'block';
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            adminActionMessage.style.display = 'none';
        }, 5000);
    }

    // Refresh users in admin user selection
    function updateAdminUserSelect() {
        if (!adminUserSelect) return;
        
        // Clear existing options
        adminUserSelect.innerHTML = '';
		
		// Add default "Select User" option
		const defaultOption = document.createElement('option');
		defaultOption.value = '';
		defaultOption.textContent = 'pick one..';
		defaultOption.selected = true;
		defaultOption.disabled = true;
		adminUserSelect.appendChild(defaultOption);
        
        // 1. Create an array from the users object
        const usersArray = [];
        Object.keys(allUsers).forEach(userId => {
            if (userId === currentUser.uid) return; // Don't add yourself
            
            const user = allUsers[userId];
            if (!user) return;
            
            usersArray.push({
                userId: userId,
                displayName: user.displayName || 'Unknown User',
                isAdmin: adminUsers[userId],
                isBanned: bannedUsers[userId],
                isLeader: window.leaderIds && window.leaderIds[userId]
            });
        });
        
        // 2. Sort the array alphabetically by displayName
        usersArray.sort((a, b) => a.displayName.localeCompare(b.displayName));
        
        // 3. Add the sorted users to the dropdown
        usersArray.forEach(user => {
            const option = document.createElement('option');
            option.value = user.userId;
            
            // Build the display text with indicators
            let displayText = user.displayName;
            if (user.isLeader) {
                displayText += ' (Leader)';
            } else if (user.isAdmin) {
                displayText += ' (Admin)';
            }
            if (user.isBanned) {
                displayText += ' (Banned)';
            }
            
            option.textContent = displayText;
            adminUserSelect.appendChild(option);
        });
    }

    // Refresh users
    function addRefreshIconAnimation() {
        const style = document.createElement('style');
        style.textContent = `
            @keyframes admin-refresh-spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
            .admin-section .refresh-icon.spinning {
                animation: admin-refresh-spin 1s linear infinite;
            }
        `;
        document.head.appendChild(style);
    }

    // Call this function once when the page loads
    addRefreshIconAnimation();

    async function refreshUsersList() {
        try {
            log("üë•üìã Refreshing users list...", 0);
            
            // Show loading state
            const refreshBtn = document.getElementById('refresh-admin-users-btn');
            if (refreshBtn) {
                refreshBtn.disabled = true;
                refreshBtn.querySelector('.refresh-icon').classList.add('spinning');
            }
            
            // Reload users from database
            await loadUsers();
            
            // Update UI
            updateAdminUserSelect();
            loadContactsList();
            
            notifications.success("users list refreshed, bro.", 'success', 3000);
        } catch (error) {
            console.error("üë•üìã‚ùå Error refreshing users list:", error);
            notifications.error("couldn't refresh users list, bro.", 'error', 5000);
        } finally {
            // Reset loading state
            const refreshBtn = document.getElementById('refresh-admin-users-btn');
            if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.querySelector('.refresh-icon').classList.remove('spinning');
            }
        }
    }

    // Add this CSS animation for the refresh icon
    const style = document.createElement('style');
    style.textContent = `
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    `;
    document.head.appendChild(style);
	
    // ====================================================================================================
    // IN-APP NOTIFICATION SYSTEM
    // ====================================================================================================
    
    class NotificationSystem {
        constructor() {
            this.container = document.getElementById('notification-container');
            this.notifications = [];
            this.maxNotifications = 5;
        }

        show(message, type = 'info', title = null, duration = 4000) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification ${type}`; // e.g., "notification success"
            
            // This HTML structure is CRITICAL for the CSS to work
            notification.innerHTML = `
                <div class="notification-icon"></div>
                <div class="notification-content">
                    ${title ? `<div class="notification-title">${title}</div>` : ''}
                    <div class="notification-message">${message}</div>
                </div>
                <button class="notification-close">√ó</button>
            `;
            
            // Add to container
            this.container.appendChild(notification);
            
            // Limit number of notifications
            if (this.notifications.length >= this.maxNotifications) {
                const oldest = this.notifications.shift();
                this.remove(oldest);
            }
            
            this.notifications.push(notification);
            
            // Show notification with animation
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Auto-dismiss
            if (duration > 0) {
                setTimeout(() => {
                    this.remove(notification);
                }, duration);
            }
            
            // Close button
            const closeBtn = notification.querySelector('.notification-close');
            closeBtn.addEventListener('click', () => {
                this.remove(notification);
            });
            
            // Click to dismiss
            notification.addEventListener('click', (e) => {
                if (!e.target.classList.contains('notification-close')) {
                    this.remove(notification);
                }
            });
            
            return notification;
        }
        
        remove(notification) {
            if (!notification || !notification.parentNode) return;
            
            notification.classList.add('hide');
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
                const index = this.notifications.indexOf(notification);
                if (index > -1) {
                    this.notifications.splice(index, 1);
                }
            }, 300);
        }
        
        // Convenience methods
        success(message, title = null, duration = 4000) {
            return this.show(message, 'success', title, duration);
        }
        
        error(message, title = null, duration = 6000) {
            return this.show(message, 'error', title, duration);
        }
        
        warning(message, title = null, duration = 5000) {
            return this.show(message, 'warning', title, duration);
        }
        
        info(message, title = null, duration = 4000) {
            return this.show(message, 'info', title, duration);
        }
        
        // Clear all notifications
        clear() {
            this.notifications.forEach(notification => {
                this.remove(notification);
            });
            this.notifications = [];
        }
    }
    
    // Create global notification instance
    const notifications = new NotificationSystem();

    // ====================================================================================================
    // BAN NOTIFICATION FUNCTIONS
    // ====================================================================================================
    
    function showBannedNotification(reason) {
        console.log("üë•üö´ showBannedNotification called with reason:", reason);
        
        const notification = document.getElementById('banned-notification');
        const reasonText = document.getElementById('ban-reason-text');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');

        if (notification) {
            notification.style.display = 'flex'; // Force display to flex
            notification.classList.add('show');
            notification.classList.add('animated-bg'); 
            if (reason && reasonText) {
                reasonText.textContent = `Reason: ${reason}`;
            }
            console.log("üë•üö´‚úÖ Notification element made visible.");
        } else {
            console.error("üë•üö´‚ùå Banned notification element not found.");
        }

        if (messageInput) messageInput.disabled = true;
        if (sendBtn) sendBtn.disabled = true;
        
        const messageInputContainer = document.getElementById('message-input-container');
        if (messageInputContainer) {
            messageInputContainer.classList.add('banned-state');
        }
    }

    function hideBannedNotification() {
        console.log("üë•‚úîÔ∏è hideBannedNotification called");
        
        const notification = document.getElementById('banned-notification');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');

        if (notification) {
            notification.style.display = 'none'; // Force display to none
            notification.classList.remove('show');
            notification.classList.remove('animated-bg'); 
            console.log("üë•‚úîÔ∏è‚úÖ Notification element hidden");
        }

        if (messageInput) messageInput.disabled = false;
        if (sendBtn) sendBtn.disabled = false;
        
        const messageInputContainer = document.getElementById('message-input-container');
        if (messageInputContainer) {
            messageInputContainer.classList.remove('banned-state');
        }
    }
    
    async function isCurrentUserBanned() {
        if (!currentUser) return false;
        
        try {
            const banSnapshot = await database.ref('bannedUsers/' + currentUser.uid).once('value');
            return banSnapshot.exists();
        } catch (error) {
            console.error("üë•üö´‚ùî Error checking ban status:", error);
            return false;
        }
    }

    // ====================================================================================================
    // ROLE MANAGEMENT FUNCTIONS
    // ====================================================================================================

    // Load role data (leaders and admins)
    async function loadRoleData() {
        log("üë§üëÆ/üëë‚ùî Loading role data...", bannedUsers, 0, 'admin');
        
        // 1. Initial check: if no user, do nothing.
        if (!currentUser) {
            console.log("üë§üëÆ‚ùé No user to load role data for. Exiting.");
            return;
        }

        // 2. CRITICAL: Reset state to prevent bleed-over from previous sessions.
        window.leaderIds = null;
        adminUsers = {};
        bannedUsers = {};

        // 3. Load Leaders Data: This is a public read and should always succeed.
        try {
            const leadersSnapshot = await database.ref('roles/leaders').once('value');
            window.leaderIds = leadersSnapshot.val() || {};
            log("‚ÑπÔ∏è Loaded leader IDs:", window.leaderIds, 1, 'admin');
        } catch (error) {
            console.error("üë§üëÆ‚ùé Error loading leader IDs:", error, 0, 'admin');
            // Even if this fails, we can continue. The app will just behave as if there are no leaders.
            window.leaderIds = {};
        }

        // 4. Load Admin Data: This is now a public read for any authenticated user.
        try {
            const adminSnapshot = await database.ref('adminUsers').once('value');
            adminUsers = adminSnapshot.val() || {};
            log("‚ÑπÔ∏è Loaded admin users:", adminUsers, 1, 'admin');
        } catch (error) {
            console.error("üë§üëÆ‚ùé Error loading admin users:", error);
            // If this fails, adminUsers remains an empty object, which is a safe default.
        }

        // 5. Load Banned Data: This is the only part that should be restricted.
        // Only admins or leaders need to see the full ban list for the admin panel.
        const isAdmin = adminUsers[currentUser.uid];
        const isLeader = isCurrentUserLeader();

        if (isAdmin || isLeader) {
            console.log("üë§üëÆ‚ÑπÔ∏è üë§=üëÆ/üëë User is admin or leader: loading banned users for admin panel.");
            try {
                const bannedSnapshot = await database.ref('bannedUsers').once('value');
                bannedUsers = bannedSnapshot.val() || {};
                log("‚ÑπÔ∏è üë§üö´‚úîÔ∏è Loaded banned users:", bannedUsers, 2, 'admin');
            } catch (bannedError) {
                console.error("üë§üëÆ‚ùé üë§üö´‚ùå Error loading banned users:", bannedError);
                if (bannedError.code === 'PERMISSION_DENIED') {
                    notifications.warning("Permission denied accessing banned users. Your Firebase security rules may need updating.", 'Security Rules Warning', 5000);
                }
                bannedUsers = {}; // Default to empty on failure.
            }
        } else {
            console.log("üë§üëÆ‚ÑπÔ∏è üë§‚â†üëÆ/üëë User is not admin or leader. Skipping full ban list load.", 1, 'admin');
        }

        log("‚úÖ Leader IDs:", window.leaderIds, 1, 'admin');
        log("‚úÖ Admin users:", adminUsers, 1, 'admin');
        log("‚úÖ Banned users:", bannedUsers, 1, 'admin');
    }

    // Update UI based on user role
    function updateUserRoleUI() {
        log("üë§üëÆüîÑÔ∏è Starting to refresh user roles...", 0, 'admin');
        log("‚ÑπÔ∏è Refreshing user role UI: Current user ID:", currentUser.uid, 1, 'admin');
        log("‚ÑπÔ∏è Refreshing user role UI: Admin users:", adminUsers, 1, 'admin');
        log("‚ÑπÔ∏è Refreshing user role UI: Leader IDs:", window.leaderIds, 1, 'admin');
        
        // Remove all role classes first
        document.body.classList.remove('is-leader', 'is-admin');
        
        if (window.leaderIds && window.leaderIds[currentUser.uid]) {
            log("üë§=üëë Setting user as LEADER", 2, 'admin');
            document.body.classList.add('is-leader');
            document.body.classList.add('is-admin'); // Leader is also an admin
            
            if (adminPanel) {
                adminPanel.style.display = 'block';
                
                // Show all controls for leader
                document.querySelectorAll('.leader-only').forEach(el => {
                    el.style.display = 'inline-block';
                });
                
                document.querySelectorAll('.admin-only').forEach(el => {
                    el.style.display = 'inline-block';
                });
            }
            
        } else if (adminUsers[currentUser.uid]) {
            log("üë§=üëÆ Setting user as ADMIN", 2, 'admin');
            document.body.classList.add('is-admin');
            
            if (adminPanel) {
                adminPanel.style.display = 'block';
                
                // Show only admin controls, hide leader-only controls
                document.querySelectorAll('.leader-only').forEach(el => {
                    el.style.display = 'none';
                });
                
                document.querySelectorAll('.admin-only').forEach(el => {
                    el.style.display = 'inline-block';
                });
            }
            
            notifications.success('admin privileges confirmed!', 'Authentication', 4000);
        } else {
            log("üë§‚â†üëÆ/üëë Setting user as REGULAR", 2, 'admin');
            // Regular user
            if (adminPanel) {
                adminPanel.style.display = 'none';
            }
        }
        
        // Update admin user select
        if (adminUsers[currentUser.uid] || isCurrentUserLeader()) {
            updateAdminUserSelect();
        }
    }

    // Show user details when selected
    function showUserDetails(userId) {
        if (!userId || !allUsers[userId]) {
            const userInfoDiv = document.getElementById('admin-user-info');
            if (userInfoDiv) userInfoDiv.style.display = 'none';
            return;
        }
        
        const user = allUsers[userId];
        const userInfoDiv = document.getElementById('admin-user-info');
        
        if (!userInfoDiv) return; // Added: Null check
        
        // Update user information
        document.getElementById('info-display-name').textContent = user.displayName || 'Unknown';
        document.getElementById('info-user-type').textContent = user.isGuest ? 'Guest' : 'Registered';
        
        // Status
        let status = 'Active';
        if (bannedUsers[userId]) {
            status = 'Banned';
        } else if (user.disabled) {
            status = 'Disabled';
        }
        document.getElementById('info-status').textContent = status;
        
        // Last seen
        if (user.lastSeen) {
            const lastSeenDate = new Date(user.lastSeen);
            document.getElementById('info-last-seen').textContent = lastSeenDate.toLocaleString();
        } else {
            document.getElementById('info-last-seen').textContent = 'Unknown';
        }
        
        userInfoDiv.style.display = 'block';
    }

    // Show confirmation modal
    function showConfirmModal(title, message, details, onConfirm) {
        const modal = document.getElementById('admin-confirm-modal');
        const titleElement = document.getElementById('confirm-title');
        const messageElement = document.getElementById('confirm-message');
        const detailsElement = document.getElementById('confirm-details');
        const confirmBtn = document.getElementById('confirm-ok-btn');
        const cancelBtn = document.getElementById('confirm-cancel-btn');
        const closeBtn = document.getElementById('confirm-close-btn');
        
        if (!modal || !titleElement || !messageElement || !detailsElement || 
            !confirmBtn || !cancelBtn || !closeBtn) {
            console.error("üì¶üëç/üëé‚ùå Missing modal elements");
            return;
        }
        
        // Set content
        titleElement.textContent = title;
        messageElement.textContent = message;
        
        // Set details if provided
        if (Object.keys(details).length > 0) {
            let detailsHtml = '';
            for (const [key, value] of Object.entries(details)) {
                detailsHtml += `<div><strong>${key}:</strong> ${value}</div>`;
            }
            detailsElement.innerHTML = detailsHtml;
            detailsElement.style.display = 'block';
        } else {
            detailsElement.style.display = 'none';
        }
        
        // Show modal
        modal.style.display = 'block';
        
        // Set up event listeners
        const handleConfirm = () => {
            modal.style.display = 'none';
            onConfirm();
            
            // Remove event listeners
            confirmBtn.removeEventListener('click', handleConfirm);
            cancelBtn.removeEventListener('click', handleCancel);
            closeBtn.removeEventListener('click', handleCancel);
        };
        
        const handleCancel = () => {
            modal.style.display = 'none';
            
            // Remove event listeners
            confirmBtn.removeEventListener('click', handleConfirm);
            cancelBtn.removeEventListener('click', handleCancel);
            closeBtn.removeEventListener('click', handleCancel);
        };
        
        confirmBtn.addEventListener('click', handleConfirm);
        cancelBtn.addEventListener('click', handleCancel);
        closeBtn.addEventListener('click', handleCancel);
        
        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            if (event.target === modal) {
                handleCancel();
            }
        });
    }

    // Ban a user (Admin and Leader can do this)
    function banUser() {
        if (!isCurrentUserAdmin() && !isCurrentUserLeader()) {
            notifications.error("u ain't allowed to do that, bro.", 'access denied', '6000');
            return;
        }
        
        const userId = adminUserSelect.value;
        const reason = adminReasonInput.value.trim();
        
        if (!userId) {
            notifications.warning('u gotta choose a user to ban, bro.', 'action required', '5000');
            return;
        }
        
        if (!reason) {
            notifications.warning('u gotta provide a reason for the ban, bro.', 'action required', '5000');
            return;
        }
        
        // Cannot ban yourself or other admins/leader
        if (userId === currentUser.uid) {
            notifications.error("u can't ban yourself, bro.", 'not allowed', '6000');
            return;
        }
        
        if (adminUsers[userId] || (window.leaderIds && window.leaderIds[userId])) {
            notifications.error("u can't ban an admin or leader, bro.", 'not allowed', '6000');
            return;
        }
        
        // Add user to banned list
        const banData = {
            reason: reason,
            bannedBy: currentUser.uid,
            bannedByName: currentUser.displayName,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        database.ref('bannedUsers/' + userId).set(banData)
            .then(() => {
                // Update local state
                bannedUsers[userId] = banData;
                
                // Update UI
                updateAdminUserSelect();
                loadContactsList();
                
                // Show success message
                notifications.success(`'${allUsers[userId]?.displayName || 'Unknown'}' is now banned, bro.`, 'success', '4000');
                
                // Clear form
                adminReasonInput.value = '';
            })
            .catch(error => {
                console.error("üë§üö´ ‚ùå Error banning user:", error);
                notifications.error("couldn't ban that user, bro. try again.", 'error', '6000');
            });
    }
    
    // Unban a user
    function unbanUser(userId) {
        if (!isCurrentUserAdmin() && !isCurrentUserLeader()) {
            notifications.error("u ain't allowed to do that, bro.", 'access denied', '6000');
            return;
        }
        
        if (!userId) {
            notifications.warning('u gotta select a user to unban, bro.', 'action required', '5000');
            return;
        }
        
        if (!bannedUsers[userId]) {
            notifications.error("that user ain't banned, bro.", 'not banned', '6000');
            return;
        }
        
        // Remove user from banned list
        database.ref('bannedUsers/' + userId).remove()
            .then(() => {
                // Update local state
                delete bannedUsers[userId];
                
                // Update UI
                updateAdminUserSelect();
                loadContactsList();
                
                // Show success message
                notifications.success(`'${allUsers[userId]?.displayName || 'Unknown'}' is now unbanned, bro.`, 'user unbanned', '4000');
            })
            .catch(error => {
                console.error("üë§‚úîÔ∏è ‚ùå Error unbanning user:", error);
                notifications.error("couldn't unban that user, bro. try again.", 'error', '6000');
            });
    }

    // Grant admin privileges (Leader only)
    function grantAdmin() {
        if (!isCurrentUserLeader()) {
            notifications.error('only leaders can grant admin privileges, bro.', 'access denied', '6000');
            return;
        }
        
        const userId = adminUserSelect.value;
        
        if (!userId) {
            notifications.warning('u gotta select a user to grant admin privileges, bro.', 'action required', '5000');
            return;
        }
        
        if (adminUsers[userId]) {
            notifications.error('that user already has admin privileges, bro.', 'already admin', '6000');
            return;
        }
        
        // Add user to admin list
        database.ref('adminUsers/' + userId).set(true)
            .then(() => {
                // Update local state
                adminUsers[userId] = true;
                
                // Update UI
                updateAdminUserSelect();
                loadContactsList();
                
                // Show success message
                notifications.success("admin privileges granted to '${allUsers[userId]?.displayName || 'Unknown'}', bro.", 'admin granted', '4000');
            })
            .catch(error => {
                console.error("üë§‚û°Ô∏èüëÆ ‚ùå Error granting admin:", error);
                notifications.error("couldn't grant admin privileges, bro. try again.", 'error', '6000');
            });
    }

    // Revoke admin privileges (Leader only)
    function revokeAdmin() {
        if (!isCurrentUserLeader()) {
            notifications.error('üëÆ‚û°Ô∏èüë§ ‚ùé üë§‚â†üëë only leaders can revoke admin privileges, bro.', 'access denied', '6000');
            return;
        }
        
        const userId = adminUserSelect.value;
        
        if (!userId) {
            notifications.warning('u gotta select a user to revoke admin privileges from, bro.', 'action required', '5000');
            return;
        }
        
        if (!adminUsers[userId]) {
            notifications.error("that user don't got admin privileges, bro.", 'error', '6000');
            return;
        }
        
        // Cannot revoke admin from yourself if you're the leader
        if (userId === currentUser.uid) {
            notifications.error('why u tryna revoke ur own admin bro.', 'not allowed', '6000');
            return;
        }
        
        // Remove user from admin list
        database.ref('adminUsers/' + userId).remove()
            .then(() => {
                // Update local state
                delete adminUsers[userId];
                
                // Update UI
                updateAdminUserSelect();
                loadContactsList();
                
                // Show success message
                notifications.success(`admin privileges revoked from '${allUsers[userId]?.displayName || 'Unknown User'}', bro.`, 'admin revoked', '4000');
            })
            .catch(error => {
                console.error("üëÆ‚û°Ô∏èüë§ ‚ùå Error revoking admin:", error);
                notifications.error("couldn't revoke admin privileges, bro. try again.", 'Error', '6000');
            });
    }

    // ====================================================================================================
    // UI COLLAPSE/EXPAND FUNCTIONS
    // ====================================================================================================
    
    // Initialize collapsed sections from localStorage
    function initCollapsedSections() {
        const saved = localStorage.getItem('collapsedSections');
        if (saved) {
            collapsedSections = JSON.parse(saved);
        } else {
            // Default: collapse rooms and users on mobile, and always collapse admin
            if (window.innerWidth <= 480) {
                collapsedSections = {
                    'recent-chats-section': false,
                    'rooms-section': false,
                    'users-section': true,
                    'admin-section': true 
                };
            } else {
                collapsedSections = {
                    'recent-chats-section': false,
                    'rooms-section': false,
                    'users-section': false,
                    'admin-section': true
                };
            }
        }
    }

    function applyCollapsedStates() {
        Object.keys(collapsedSections).forEach(sectionId => {
            const section = document.getElementById(sectionId);
            const content = document.getElementById(sectionId.replace('-section', '-content'));
            const toggle = section ? section.querySelector('.collapse-toggle') : null;
        
            if (section && content && toggle) {
                if (collapsedSections[sectionId]) {
                    content.classList.add('collapsed');
                    toggle.classList.add('collapsed');
                    toggle.textContent = '‚ñ∂';
                } else {
                    content.classList.remove('collapsed');
                    toggle.classList.remove('collapsed');
                    toggle.textContent = '‚ñº';
                }
            }
        });
    }

    // Toggle section collapse
    function toggleSection(sectionId) {
        collapsedSections[sectionId] = !collapsedSections[sectionId];
        localStorage.setItem('collapsedSections', JSON.stringify(collapsedSections));
        applyCollapsedStates();
    }

    // ====================================================================================================
    // AUTHENTICATION FUNCTIONS
    // ====================================================================================================
    
    // Auth tab switching
    function switchAuthTab(tab) {
        if (!guestTab || !accountTab || !guestPanel || !accountPanel || 
            !signupPanel || !usernamePanel) {
            console.error("üóÇÔ∏è ‚ùå Missing auth tab elements");
            return;
        }
        
        if (tab === 'guest') {
            guestTab.classList.add('active');
            accountTab.classList.remove('active');
            guestPanel.classList.add('active');
            accountPanel.classList.remove('active');
            signupPanel.classList.remove('active');
            usernamePanel.classList.remove('active');
        } else {
            accountTab.classList.add('active');
            guestTab.classList.remove('active');
            accountPanel.classList.add('active');
            guestPanel.classList.remove('active');
            signupPanel.classList.remove('active');
            usernamePanel.classList.remove('active');
        }
    }

    function switchAuthPanel(panel) {
        if (!guestPanel || !accountPanel || !signupPanel || !usernamePanel) {
            console.error("üóÇ ‚ùå Missing auth panel elements");
            return;
        }
        
        // Hide all panels first
        guestPanel.classList.remove('active');
        accountPanel.classList.remove('active');
        signupPanel.classList.remove('active');
        usernamePanel.classList.remove('active');
        
        // Show the requested panel
        if (panel === 'signup') {
            signupPanel.classList.add('active');
        } else if (panel === 'login') {
            accountPanel.classList.add('active');
        } else if (panel === 'username') {
            usernamePanel.classList.add('active');
        }
    }

    // Login as guest - Fixed race condition
    function loginAsGuest() {
        const username = guestUsername.value.trim();
        if (!username) {
            notifications.error('u gotta enter a username , bro.', 'action required', '6000');
            return;
        }
        
        // Loading animation START
        setButtonLoading(guestLoginBtn, true);
        
        // Check if username is taken first, then sign in
        const username_lower = username.toLowerCase();
        database.ref('users').orderByChild('displayName_lower').equalTo(username_lower).once('value')
            .then(snapshot => {
                if (snapshot.exists()) {
                    // Name is taken, show error and stop
                    notifications.error(`"${username}" is taken, bro. choose another.`, 'error', '6000');
                    setButtonLoading(guestLoginBtn, false);
                    return Promise.reject(new Error('Username taken'));
                }
                
                // Name is available, proceed with authentication
                return auth.signInAnonymously();
            })
            .then(userCredential => {
                currentUser = userCredential.user;
                console.log("üë§ü§® ‚úÖ Guest signed in successfully");
                
                // Save the guest's data to the database
                return database.ref('users/' + currentUser.uid).set({
                    displayName: username,
                    displayName_lower: username.toLowerCase(),
                    isGuest: true,
                    isAdmin: false, // Guests cannot be admins
                    lastSeen: firebase.database.ServerValue.TIMESTAMP,
                    uid: currentUser.uid
                });
            })
            .then(() => {
                // Update the user's profile and enter the app
                return currentUser.updateProfile({ displayName: username });
            })
            .then(() => {
                setupUser();
            })
            .catch(error => {
                console.error("couldn't sign u in as guest bro. error:", error);
                if (error.message !== 'Username taken') {
                    notifications.error(error.message);
                }
            })
            .finally(() => {
                // Re-enable the button regardless of outcome
                setButtonLoading(guestLoginBtn, false);
            });
    }

    // Login with email
    function loginWithEmail() {
        const email = emailInput.value.trim();
        const password = passwordInput.value;
        
        if (email && password) {
            // Loading animation START
            setButtonLoading(loginBtn, true);

            auth.signInWithEmailAndPassword(email, password)
                .then(userCredential => {
                    currentUser = userCredential.user;
                    
                    // Reload user to get latest emailVerified status
                    return currentUser.reload();
                })
                .then(() => {
                    console.log("Email user signed in:", currentUser);
                    
                    // Check if user has a display name
                    if (!currentUser.displayName || currentUser.displayName === '') {
                        // Show username selection panel
                        switchAuthPanel('username');
                    } else {
                        // User already has a display name, proceed
                        setupUser();
                    }
                    
                    // Update verification status in UI
                    updateVerificationUI();
                })
                .catch(error => {
                    console.error("üìß‚û°Ô∏è ‚ùå Error signing in:", error);
                    
                    // Custom error messages for common issues
                    let specificMessage = "";

                    if (error.code === 'auth/user-not-found') {
                        specificMessage = "ur account wasn't found.";
                    } else if (error.code === 'auth/invalid-login-credentials') {
                        specificMessage = "that might be the wrong email/password combination.";
                    } else if (error.code === 'auth/wrong-password') {
                        specificMessage = "that's the wrong password.";
                    } else if (error.code === 'auth/invalid-email') {
                        specificMessage = "that email isn't in the correct format.";
                    } else if (error.code === 'auth/user-disabled') {
                        specificMessage = "ur account's been disabled by a leader.";
                    } else if (error.code === 'auth/too-many-requests') {
                        specificMessage = "u tried logging in too many times. try again later.";
                    }

                    // Always show base message + specific if available
                    if (specificMessage) {
                        notifications.error("couldn't sign u in, mate." + " " + specificMessage);
                    } else {
                        notifications.error("couldn't sign u in, mate." + " " + error.message);
                    }

                    // Debug the actual error code
                    console.log("üìß‚û°Ô∏è ‚ùå Error code:", error.code);
                })
                .finally(() => {
                    // Loading animation END
                    setButtonLoading(loginBtn, false);
                });
        } else {
            notifications.warning('u gotta enter an email and password, mate.');
        }
    }
    
    // Send verification email
    function sendEmailVerification() {
        if (!currentUser) {
            notifications.error('u gotta log in first, mate.');
            return;
        }
        
        if (currentUser.emailVerified) {
            notifications.error('ur email is already verified, bro.');
            return;
        }
        
        // Show loading state
        const verifyButton = document.getElementById('verify-email-btn');
        if (verifyButton) {
            verifyButton.disabled = true;
            verifyButton.textContent = 'sending...';
        }
        
        currentUser.sendEmailVerification()
            .then(() => {
                // Update tooltip message
                const tooltipStatus = document.getElementById('tooltip-status');
                if (tooltipStatus) {
                    tooltipStatus.textContent = 'email sent! check your inbox and spam folders.';
                    tooltipStatus.style.color = '#4caf50';
                    
                    // Reset after 5 seconds
                    setTimeout(() => {
                        tooltipStatus.textContent = 'email not verified';
                        tooltipStatus.style.color = '#f44336';
                    }, 5000);
                }
            })
            .catch(error => {
                console.error("üì©‚úîÔ∏è ‚ùå Error sending verification email:", error);
                
                // Update tooltip message
                const tooltipStatus = document.getElementById('tooltip-status');
                if (tooltipStatus) {
                    tooltipStatus.textContent = `error: ${error.message}`;
                    tooltipStatus.style.color = '#f44336';
                    
                    // Reset after 5 seconds
                    setTimeout(() => {
                        tooltipStatus.textContent = 'email not verified';
                        tooltipStatus.style.color = '#f44336';
                    }, 5000);
                }
            })
            .finally(() => {
                // Restore button state
                if (verifyButton) {
                    verifyButton.disabled = false;
                    verifyButton.textContent = 'verify email';
                }
            });
    }

    // Update UI based on verification status
    function updateVerificationUI() {
        const container = document.getElementById('email-verification-icon');
        const icon = document.getElementById('verification-icon');
        const tooltipStatus = document.getElementById('tooltip-status');
        const tooltipEmail = document.getElementById('tooltip-email');
        const verifyBtn = document.getElementById('verify-email-btn');
        
        if (!container || !icon || !tooltipStatus) return;
        
        // Only show verification UI for non-anonymous users
        if (currentUser && !currentUser.isAnonymous) {
            container.style.display = 'block';
            
            if (currentUser.emailVerified) {
                // Verified state
                icon.className = 'verification-icon verified';
                icon.textContent = '‚úì';
                tooltipStatus.textContent = 'email verified';
                tooltipStatus.style.color = '#4caf50';
                if (verifyBtn) verifyBtn.style.display = 'none';
            } else {
                // Unverified state
                icon.className = 'verification-icon not-verified';
                icon.textContent = '‚úï';
                tooltipStatus.textContent = 'email not verified';
                tooltipStatus.style.color = '#f44336';
                if (verifyBtn) verifyBtn.style.display = 'block';
            }
            
            // Show email in tooltip
            if (currentUser.email && tooltipEmail) {
                tooltipEmail.textContent = currentUser.email;
            }
        } else {
            container.style.display = 'none';
        }
    }

    // Set username for new users
    function setUsername() {
        const username = chooseUsername.value.trim();
        
        if (username && currentUser) {
            // Loading animation START
            setButtonLoading(setUsernameBtn, true);

            // Update the user's profile with the chosen username
            currentUser.updateProfile({ displayName: username })
                .then(() => {
                    // Also save the lowercase name to the database
                    return database.ref('users/' + currentUser.uid).update({
                        displayName: username,
                        displayName_lower: username.toLowerCase(),
                        uid: currentUser.uid
                    });
                })
                .then(() => {
                    // Proceed to app
                    setupUser();
                })
                .catch(error => {
                    console.error("üë§üìõ ‚ùå Set username failed. Error:", error);
                    notifications.error("couldn't set that username for u, bro. check the console for details.", "that didn't work", '6000');
                })
                .finally(() => {
                    // Loading animation END
                    setButtonLoading(setUsernameBtn, false);
                });
        } else {
            notifications.warning('u gotta enter a username, mate.');
        }
    }

    // Sign up new user
	function signUp() {
		const email = signupEmail.value.trim();
		const password = signupPassword.value;
		const name = displayName.value.trim();
		
		// Validate inputs
		if (!email || !password || !name) {
			notifications.error('Please fill all fields', 'Validation Error', 3000);
			return;
		}
		
		if (password.length < 6) {
			notifications.error('Password must be at least 6 characters', 'Validation Error', 3000);
			return;
		}
        
        if (email && password && name) {
            // Loading animation START
            setButtonLoading(signupBtn, true);

            auth.createUserWithEmailAndPassword(email, password)
                .then(userCredential => {
                    // Update display name in Firebase Auth
                    return userCredential.user.updateProfile({ displayName: name });
                })
                .then(() => {
                    currentUser = auth.currentUser;
                    
                    // Send verification email
                    return currentUser.sendEmailVerification();
                })
                .then(() => {
                    // Save user data to database
                    const displayName = currentUser.displayName || 'New User';
                    return database.ref('users/' + currentUser.uid).set({
                        displayName: displayName,
                        displayName_lower: displayName.toLowerCase(),
                        isGuest: false,
                        isAdmin: false,
                        emailVerified: false,
                        email: email,
                        createdAt: firebase.database.ServerValue.TIMESTAMP,
                        lastSeen: firebase.database.ServerValue.TIMESTAMP,
                        uid: currentUser.uid
                    });
                })
                .then(() => {
                    // Show verification message
                    notifications.success('thanks for joining whisper, bro! make sure u verify ur email to send messages. u might have to check ur spam folder too.', 'thanks!', '10000');
                    
                    // Set up user
                    setupUser();
                })
                .catch(error => {
                    console.error("couldn't sign u up, mate. error:", error);
                    notifications.error(error.message);
                })
                .finally(() => {
                    // Loading animation END
                    setButtonLoading(signupBtn, false);
                });
        } else {
            notifications.warning('u gotta fill all fields, mate.');
        }
    }

    // Reset password
    function resetPassword() {
        const email = emailInput.value.trim();
        
        if (!email) {
            notifications.warning('u gotta enter your email address first, bro.');
            return;
        }

        // Show a loading state on the button
        const originalText = resetPasswordBtn.textContent;
        resetPasswordBtn.textContent = 'sending...';
        resetPasswordBtn.disabled = true;

        auth.sendPasswordResetEmail(email)
            .then(() => {
                notifications.success('password reset email sent, bro! check your email. try looking in your spam folder too.', 'done', '10000');
            })
            .catch(error => {
                console.error(" error:", error);
                notifications.error("couldn't send that password reset email, bro. check the console for details.", "that didn't work", '6000');
            })
            .finally(() => {
                // Restore the button
                resetPasswordBtn.textContent = originalText;
                resetPasswordBtn.disabled = false;
            });
    }

    function logout() {
        log("...‚¨ÖÔ∏èüöóüö™ ‚ÑπÔ∏è Logging out..", 0, 'auth');
        
        // Detach all database listeners FIRST
        database.ref().off();
        
        // Clean up specific listeners
        if (currentMessagesRef) {
            currentMessagesRef.off();
            currentMessagesRef = null;
        }
        if (usersValueCallback) {
            database.ref('users').off('value', usersValueCallback);
            usersValueCallback = null;
        }
        
        // IMPORTANT: Clean up ban status listener
        if (currentUser) {
            database.ref('bannedUsers/' + currentUser.uid).off();
        }
        
        if (usersValueCallback) {
            database.ref('users').off('value', usersValueCallback);
            usersValueCallback = null;
        }
    
        log("‚úîÔ∏è All listeners have been detached.", 1, 'auth');

        // Sign out from Firebase
        if (currentUser) {
            auth.signOut().then(() => {
                log("‚úîÔ∏è Firebase sign-out successful.", 1, 'auth');
            }).catch(error => {
                console.error("‚¨ÖÔ∏èüöó..üö™ ‚ùå Firebase sign-out failed:", error);
            });
        }
        currentUser = null;
        
        // Clear intervals
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;
        }
        
        if (window.verificationCheckInterval) {
            clearInterval(window.verificationCheckInterval);
            window.verificationCheckInterval = null;
        }
        
        // Clear local state
        currentRoom = 'general';
        privateChatUser = null;
        recentChats = [];
        // allUsers = {}; 
        // bannedUsers = {}; 
        // adminUsers = {}; 
        
        // Reset UI classes
        document.body.classList.remove('is-admin', 'is-logged-in');
        const appContainer = document.querySelector('.app-container');
        if (appContainer) {
            appContainer.classList.remove('user-logged-in');
        }
        
        // Hide admin panel
        if (adminPanel) adminPanel.style.display = 'none';
        
        // Force clear any remaining messages
        if (messages) messages.innerHTML = '';
        log("‚úîÔ∏è Messages cleared", 1, 'auth');
        
        if (window.currentUserBanStatusRef) {
            window.currentUserBanStatusRef.off();
            window.currentUserBanStatusRef = null;
        }
        
        // Show auth screen with proper z-index
        if (authContainer) {
            authContainer.style.display = 'flex';
            authContainer.style.position = 'relative';
            authContainer.style.zIndex = '1000';
            authContainer.style.backgroundColor = ''; // Ensure it's not transparent
        }
        
        // Hide app main completely
        if (appMain) {
            appMain.style.display = 'none';
            appMain.classList.remove('visible');
        }
        
        // Force DOM reflow to ensure changes take effect
        void document.body.offsetHeight;
        
        // Switch to login tab with slight delay
        setTimeout(() => {
            switchAuthTab('account');
            switchAuthPanel('login');
            
            // Ensure auth container is fully visible
            if (authContainer) {
                authContainer.scrollIntoView({ behavior: 'instant', block: 'start' });
            }
        }, 50);
        
        log("üöó‚¨ÖÔ∏è...üö™‚úÖ Logout successful!", 0, 'auth');
    }

    // ====================================================================================================
    // USER SETUP AND DATA LOADING FUNCTIONS
    // ====================================================================================================
    
    // Setup user after authentication
    async function setupUser() {
        try {
            log("üë§‚öôÔ∏è ‚ÑπÔ∏è Setting up user..", 0, 'user');
            
            // --- 1. SET DEFAULT STATE ---
            currentRoom = 'general';
            privateChatUser = null;
            
            log("‚úîÔ∏è Default states set", 1, 'user');
            
            // --- 2. UI & STATE SETUP ---
            document.body.classList.add('is-logged-in');
            document.querySelector('.app-container').classList.add('user-logged-in');

            const displayName = currentUser.displayName || 'User';
            userName.textContent = displayName;
            const avatarText = displayName && displayName.length > 0 ? displayName.charAt(0).toUpperCase() : 'U';
            userAvatar.textContent = avatarText;

            // Show the main app and the loading overlay
            if (authContainer) {
                authContainer.style.display = 'none';
            }
            if (appMain) {
                appMain.style.display = 'flex';
            }
            
            const loadingOverlay = document.getElementById('messages-loading-container');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'flex';
            }
            
            log("‚úîÔ∏è UI/states set", 1, 'user');

            // --- 3. DATABASE & LISTENER SETUP ---
            const userRef = database.ref('users/' + currentUser.uid);
            
            // Update user data in database
            await userRef.update({
                displayName: displayName,
                displayName_lower: displayName.toLowerCase(),
                isGuest: currentUser.isAnonymous || false,
                lastSeen: firebase.database.ServerValue.TIMESTAMP
            });
            
            // Set up disconnect handler
            userRef.onDisconnect().update({
                isOnline: false,
                lastSeen: firebase.database.ServerValue.TIMESTAMP
            });
            
            log("‚úîÔ∏è Database and listeners loaded", 1, 'user');

            // --- 4. LOAD ROLE DATA ---
            try {
                log("‚ÑπÔ∏è Waiting to load role data...", 1, 'user');
                
                // Load all role data and wait for it to complete
                await loadRoleData();
                
                log("‚úîÔ∏è Role data loaded successfully", 2, 'user');
                log("‚úîÔ∏è Leader IDs:", window.leaderIds, 3, 'user');
                log("‚úîÔ∏è Admin users:", adminUsers, 3, 'user');
                log("‚úîÔ∏è Banned users:", bannedUsers, 3, 'user');
                
            } catch (error) {
                console.error("‚ùå Error loading role data:", error, 1, 'auth');
            }

            // --- 5. LOAD USERS DATA ---
            // Load all users first before proceeding
            await loadUsers();
            setupUsersListener();
            log("‚úîÔ∏è Users loaded.", 1, 'user');

            // --- 6. CHECK BAN STATUS ---
            try {
                log("‚ÑπÔ∏è Checking ban status for user:", currentUser.uid, 1, 'ban');
                const banSnapshot = await database.ref('bannedUsers/' + currentUser.uid).once('value');
                if (banSnapshot.exists()) {
                    const banData = banSnapshot.val();
                    log("‚ÑπÔ∏è üë§üö´ User is banned. Reason:", banData.reason, 2, 'ban');
                    showBannedNotification(banData.reason || 'No reason provided.');
                } else {
                    log("‚ÑπÔ∏è üë§‚úîÔ∏è User is not banned.", 2, 'ban');
                    hideBannedNotification();
                }
            } catch (banError) {
                console.error("‚ùå Error checking ban status:", banError);
                hideBannedNotification();
            }

            // --- 7. SET UP REAL-TIME LISTENERS ---
            
            log("‚ÑπÔ∏è Setting up listeners", 1, 'user');

            // Listen for changes to the current user's ban status
            const banStatusRef = database.ref('bannedUsers/' + currentUser.uid);
            banStatusRef.on('value', (snapshot) => {
                console.log("üîß Ban status changed for user:", currentUser.uid);
                console.log("üîß Ban data:", snapshot.val());
                
                if (snapshot.exists()) {
                    // User is banned
                    const banData = snapshot.val();
                    console.log("üö´ User is banned. Reason:", banData.reason);
                    showBannedNotification(banData.reason || 'No reason provided.');
                } else {
                    // User is not banned
                    console.log("‚úÖ User is not banned.");
                    hideBannedNotification();
                }
            });

            // Store the reference so we can detach it later
            window.currentUserBanStatusRef = banStatusRef;

            // --- 8. SET UP PERIODIC UPDATES ---
            
            // Set up periodic heartbeat
            if (heartbeatInterval) clearInterval(heartbeatInterval);
            heartbeatInterval = setInterval(() => {
                if (currentUser) {
                    userRef.update({ 
                        lastSeen: firebase.database.ServerValue.TIMESTAMP 
                    });
                }
            }, 30000);

            // Set up email verification check for non-guest users
            if (currentUser && !currentUser.isAnonymous) {
                window.verificationCheckInterval = setInterval(() => {
                    console.log("üîß Checking email verification status...");
                    currentUser.reload().then(() => {
                        updateVerificationUI();
                    }).catch(error => {
                        console.error("Error reloading user for email check:", error);
                    });
                }, 30000); // 30 seconds
            }

            // --- 9. UPDATE UI BASED ON USER ROLE ---
            log("Updating UI based on user role...", 1, 'user');
            log("Is admin:", adminUsers[currentUser.uid], 2, 'user');
            log("Is leader:", isCurrentUserLeader(), 2, 'user');
            
            // Check if user is admin and update UI accordingly
            if (adminUsers[currentUser.uid]) {
                log("User is admin, showing admin panel", 2, 'user');
                document.body.classList.add('is-admin');
                if (adminPanel) {
                    adminPanel.style.display = 'block';
                    
                    // Manually collapse admin section by default
                    const adminContent = document.getElementById('admin-content');
                    const adminToggle = document.querySelector('#admin-section .collapse-toggle');
                    
                    if (adminContent && adminToggle) {
                        adminContent.classList.add('collapsed');
                        adminToggle.classList.add('collapsed');
                        adminToggle.textContent = '‚ñ∂';
                    }
                }

            } else {
                log("User is not admin, hiding admin panel", 2, 'user');
                document.body.classList.remove('is-admin');
                if (adminPanel) {
                    adminPanel.style.display = 'none';
                }
            }
            
            // Check if user is leader
            if (isCurrentUserLeader()) {
                log("User is leader", 2, 'user');
                document.body.classList.add('is-leader');
                document.body.classList.add('is-admin'); // Leader is also an admin
                
                if (adminPanel) {
                    adminPanel.style.display = 'block';
                    
                    // Show all controls for leader
                    document.querySelectorAll('.leader-only').forEach(el => {
                        el.style.display = 'inline-block';
                    });
                    
                    document.querySelectorAll('.admin-only').forEach(el => {
                        el.style.display = 'inline-block';
                    });
                }
            }
            
            // Update roles
            updateUserRoleUI();
            
            // Check admins
            log("Building contacts list. adminUsers object is:", adminUsers, 1, 'user');
            loadContactsList();
            
            // Load rooms
            loadRooms();
            
            // Check if user is verified
            updateVerificationUI();
            
            // Load messages for the default room
            loadMessages();
            
            // Set up other real-time listeners
            setupTypingListeners();
            setupAdminListeners();
            
            // Clean up stale users after a delay
            setTimeout(cleanupStaleUsers, 5000);

            // Hide the loader and fade in the app
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
            const appMainElement = document.getElementById('app-main');
            if (appMainElement) {
                appMainElement.classList.add('visible');
            }

        } catch (error) {
            console.error("‚ùå CRITICAL ERROR in setupUser:", error);
            notifications.error("a critical error occurred during login, bro. check the console for details.", 'CRITICAL ERROR', 10000);
            
            // Ensure UI is in a usable state even on error
            if (loadingOverlay) loadingOverlay.style.display = 'none';
            const appMainElement = document.getElementById('app-main');
            if (appMainElement) appMainElement.classList.add('visible');
        }
        
        log("üë§‚öôÔ∏è User has been set up!", 0, 'user');
    }

    // Load initial app data
    async function loadInitialAppData() {
        try {
            console.log("üîß loadInitialAppData: Starting to load initial data...");
            
            const initialLoadPromises = [
                loadRoomsInitial(),
                loadUsers(),
                loadRecentChatsInitial()
            ];

            await Promise.all(initialLoadPromises);
            
            console.log("‚úÖ All initial data loaded. Hiding loader and fading in app.");
            
            // Hide the loader and fade in the app
            const loadingOverlay = document.getElementById('messages-loading-container');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
            const appMainElement = document.getElementById('app-main');
            if (appMainElement) {
                appMainElement.classList.add('visible');
            }
            
        } catch (error) {
            console.error("‚ùå Error during initial data load:", error);
            notifications.error("couldn't load initial app data, bro. refresh the page and try again.", 'CRITICAL ERROR', '10000');
            
            // Still hide the loader so the user isn't stuck
            const loadingOverlay = document.getElementById('messages-loading-container');
            if (loadingOverlay) loadingOverlay.style.display = 'none';
            const appMainElement = document.getElementById('app-main');
            if (appMainElement) appMainElement.classList.add('visible');
        }
    }

    // Load initial rooms data
    function loadRoomsInitial() {
        return database.ref('rooms').once('value').then(snapshot => {
            const rooms = [];
            snapshot.forEach(childSnapshot => {
                const room = childSnapshot.val();
                rooms.push(room);
            });
            return rooms;
        });
    }

    // Load initial recent chats
    function loadRecentChatsInitial() {
        if (!currentUser) return Promise.resolve();
        
        return database.ref('recentChats/' + currentUser.uid).once('value').then(snapshot => {
            const recentChats = [];
            snapshot.forEach(childSnapshot => {
                recentChats.push(childSnapshot.key);
            });
            return recentChats;
        });
    }

    // Load initial users data
    function loadUsersInitial() {
        return database.ref('users').once('value').then(snapshot => {
            allUsers = {};
            snapshot.forEach(childSnapshot => {
                const user = childSnapshot.val();
                const userId = childSnapshot.key;
                allUsers[userId] = user;
            });
            return allUsers;
        });
    }
    
    function setupUsersListener() {
        console.log("üîß Setting up real-time users listener...");
        
        // Detach any old listener first to prevent duplicates
        if (usersValueCallback) {
            database.ref('users').off('value', usersValueCallback);
        }

        // Create the new listener
        usersValueCallback = (snapshot) => {
            console.log("üîß Users data updated in real-time. Rebuilding contact list.");
            allUsers = snapshot.val() || {};
            loadContactsList(); // Rebuild the contacts list with the new data
        };

        // Attach the listener to the 'users' node
        database.ref('users').on('value', usersValueCallback);
    }

    // ====================================================================================================
    // ROOM MANAGEMENT FUNCTIONS
    // ====================================================================================================
    
    // Load rooms
    function loadRooms() {
        database.ref('rooms').once('value', snapshot => {
            if (snapshot.exists()) {
                if (!roomList) return; // Added: Null check
                
                roomList.innerHTML = '';
                snapshot.forEach(childSnapshot => {
                    const room = childSnapshot.val();
                    const roomElement = document.createElement('div');
                    roomElement.classList.add('room-item');
                    roomElement.dataset.room = childSnapshot.key;
                    roomElement.textContent = room.name;
                    
                    if (childSnapshot.key === currentRoom) {
                        roomElement.classList.add('active');
                    }
                    
                    roomList.appendChild(roomElement);
                });
            }
        });
    }

    // Add new room
    function addRoomFromModal() {
        const roomName = newRoomNameModal.value.trim();
        if (!roomName) {
            if (newRoomErrorMessage) {
                newRoomErrorMessage.textContent = 'Please enter a room name.';
                newRoomErrorMessage.style.display = 'block';
            }
            return;
        }

        const roomId = roomName.toLowerCase().replace(/\s+/g, '-');
        database.ref('rooms/' + roomId).set({
            name: roomName
        }).then(() => {
            // Success: close modal and clear input
            if (newRoomModal) newRoomModal.style.display = 'none';
            if (newRoomNameModal) newRoomNameModal.value = '';
            if (newRoomErrorMessage) newRoomErrorMessage.style.display = 'none';
            loadRooms(); // Refresh the room list
        }).catch(error => {
            // Error: show error message
            console.error("Error adding room:", error);
            if (newRoomErrorMessage) {
                newRoomErrorMessage.textContent = 'Failed to create room. Please try again.';
                newRoomErrorMessage.style.display = 'block';
            }
        });
    }

	// Switch to a different room
	function switchRoom(roomId) {
		// NEW: Clear typing indicators
		clearAllTypingIndicators();
		
		// Detach any existing message listener
		if (currentMessagesRef) {
			currentMessagesRef.off();
			currentMessagesRef = null;
		}
        
        // Update state
        currentRoom = roomId;
        privateChatUser = null;
        
        loadContactsList();
        
        // Update UI
        document.querySelectorAll('.room-item').forEach(item => {
            item.classList.remove('active');
            if (item.dataset.room === roomId) {
                item.classList.add('active');
            }
        });
        
        const roomElement = document.querySelector(`.room-item[data-room="${roomId}"]`);
        if (roomElement && currentRoomName) {
            currentRoomName.textContent = roomElement.textContent;
        }
        
        // Load messages for the new room
        loadMessages();
    }

    // ====================================================================================================
    // USER MANAGEMENT FUNCTIONS
    // ====================================================================================================
    
    // USER SETTINGS ========================================
    
    // Settings state
    let settings = {
        theme: localStorage.getItem('theme') || 'dark',
        fontSize: localStorage.getItem('fontSize') || '14',
        messageStyle: localStorage.getItem('messageStyle') || 'bubbles',
        soundNotifications: localStorage.getItem('soundNotifications') === 'true',
        desktopNotifications: localStorage.getItem('desktopNotifications') === 'true',
        messagePreview: localStorage.getItem('messagePreview') === 'true',
        showOnlineStatus: localStorage.getItem('showOnlineStatus') !== 'false',
        readReceipts: localStorage.getItem('readReceipts') === 'true',
        typingIndicators: localStorage.getItem('typingIndicators') !== 'false',
        autoScroll: localStorage.getItem('autoScroll') !== 'false',
        timestampFormat: localStorage.getItem('timestampFormat') || '12h'
    };

    // Show settings panel
    function showSettingsPanel() {
        console.log('Opening settings panel...');
        const panel = document.getElementById('settings-panel');
        if (panel) {
            panel.style.display = 'block';
            setTimeout(() => {
                panel.classList.add('open');
            }, 10);
            loadSettingsValues();
        } else {
            console.error('Settings panel not found');
        }
    }

    // Hide settings panel
    function hideSettingsPanel() {
        console.log('Closing settings panel...');
        const panel = document.getElementById('settings-panel');
        if (panel) {
            panel.classList.remove('open');
            setTimeout(() => {
                panel.style.display = 'none';
            }, 300);
        }
    }

    // Load settings values into UI
    function loadSettingsValues() {
        console.log('Loading settings values...');
        
        // Theme
        const themeSelect = document.getElementById('theme-select');
        if (themeSelect) themeSelect.value = settings.theme;
        
        // Font size
        const fontSizeSlider = document.getElementById('font-size-slider');
        const fontSizeValue = document.getElementById('font-size-value');
        if (fontSizeSlider) fontSizeSlider.value = settings.fontSize;
        if (fontSizeValue) fontSizeValue.textContent = settings.fontSize + 'px';
        
        // Message style
        const messageStyleSelect = document.getElementById('message-style-select');
        if (messageStyleSelect) messageStyleSelect.value = settings.messageStyle;
        
        // Checkboxes
        const soundNotifications = document.getElementById('sound-notifications');
        const desktopNotifications = document.getElementById('desktop-notifications');
        const messagePreview = document.getElementById('message-preview');
        const showOnlineStatus = document.getElementById('show-online-status');
        const readReceipts = document.getElementById('read-receipts');
        const typingIndicators = document.getElementById('typing-indicators');
        const autoScroll = document.getElementById('auto-scroll');
        
        if (soundNotifications) soundNotifications.checked = settings.soundNotifications;
        if (desktopNotifications) desktopNotifications.checked = settings.desktopNotifications;
        if (messagePreview) messagePreview.checked = settings.messagePreview;
        if (showOnlineStatus) showOnlineStatus.checked = settings.showOnlineStatus;
        if (readReceipts) readReceipts.checked = settings.readReceipts;
        if (typingIndicators) typingIndicators.checked = settings.typingIndicators;
        if (autoScroll) autoScroll.checked = settings.autoScroll;
        
        // Timestamp format
        const timestampFormatSelect = document.getElementById('timestamp-format');
        if (timestampFormatSelect) timestampFormatSelect.value = settings.timestampFormat;
        
        // Username
        const settingsUsername = document.getElementById('settings-username');
        if (settingsUsername && currentUser) {
            settingsUsername.value = currentUser.displayName || '';
        }
    }

    // Save settings
    function saveSettings() {
        console.log('Saving settings...');
        
        // Get values from UI
        const themeSelect = document.getElementById('theme-select');
        const fontSizeSlider = document.getElementById('font-size-slider');
        const messageStyleSelect = document.getElementById('message-style-select');
        const soundNotifications = document.getElementById('sound-notifications');
        const desktopNotifications = document.getElementById('desktop-notifications');
        const messagePreview = document.getElementById('message-preview');
        const showOnlineStatus = document.getElementById('show-online-status');
        const readReceipts = document.getElementById('read-receipts');
        const typingIndicators = document.getElementById('typing-indicators');
        const autoScroll = document.getElementById('auto-scroll');
        const timestampFormatSelect = document.getElementById('timestamp-format');
        
        if (themeSelect) settings.theme = themeSelect.value;
        if (fontSizeSlider) settings.fontSize = fontSizeSlider.value;
        if (messageStyleSelect) settings.messageStyle = messageStyleSelect.value;
        if (soundNotifications) settings.soundNotifications = soundNotifications.checked;
        if (desktopNotifications) settings.desktopNotifications = desktopNotifications.checked;
        if (messagePreview) settings.messagePreview = messagePreview.checked;
        if (showOnlineStatus) settings.showOnlineStatus = showOnlineStatus.checked;
        if (readReceipts) settings.readReceipts = readReceipts.checked;
        if (typingIndicators) settings.typingIndicators = typingIndicators.checked;
        if (autoScroll) settings.autoScroll = autoScroll.checked;
        if (timestampFormatSelect) settings.timestampFormat = timestampFormatSelect.value;
        
        // Save to localStorage
        localStorage.setItem('theme', settings.theme);
        localStorage.setItem('fontSize', settings.fontSize);
        localStorage.setItem('messageStyle', settings.messageStyle);
        localStorage.setItem('soundNotifications', settings.soundNotifications);
        localStorage.setItem('desktopNotifications', settings.desktopNotifications);
        localStorage.setItem('messagePreview', settings.messagePreview);
        localStorage.setItem('showOnlineStatus', settings.showOnlineStatus);
        localStorage.setItem('readReceipts', settings.readReceipts);
        localStorage.setItem('typingIndicators', settings.typingIndicators);
        localStorage.setItem('autoScroll', settings.autoScroll);
        localStorage.setItem('timestampFormat', settings.timestampFormat);
        
        // Apply settings
        applySettings();
        
        if (notifications && notifications.success) {
            notifications.success('Settings saved successfully!', 'Success', 3000);
        }
    }

    // Apply settings
    function applySettings() {
        console.log('Applying settings...');
        
        // Apply theme
        document.body.className = document.body.className.replace(/theme-\w+/g, '');
        document.body.classList.add(`theme-${settings.theme}`);
        
        // Apply font size
        document.documentElement.style.setProperty('--font-size', settings.fontSize + 'px');
        
        // Apply message style
        document.body.className = document.body.className.replace(/message-style-\w+/g, '');
        document.body.classList.add(`message-style-${settings.messageStyle}`);
        
        // Request desktop notifications permission
        if (settings.desktopNotifications && 'Notification' in window) {
            Notification.requestPermission();
        }
    }

    // Reset settings
    function resetSettings() {
        if (confirm('Are you sure you want to reset all settings to default?')) {
            localStorage.clear();
            settings = {
                theme: 'dark',
                fontSize: '14',
                messageStyle: 'bubbles',
                soundNotifications: false,
                desktopNotifications: false,
                messagePreview: true,
                showOnlineStatus: true,
                readReceipts: false,
                typingIndicators: true,
                autoScroll: true,
                timestampFormat: '12h'
            };
            loadSettingsValues();
            applySettings();
            if (notifications && notifications.success) {
                notifications.success('Settings reset to default', 'Success', 3000);
            }
        }
    }

    // Change username
    async function changeUsername() {
        const settingsUsername = document.getElementById('settings-username');
        if (!settingsUsername) return;
        
        const newUsername = settingsUsername.value.trim();
        
        if (!newUsername) {
            if (notifications && notifications.error) {
                notifications.error('Please enter a username', 'Error', 3000);
            }
            return;
        }
        
        if (newUsername === currentUser.displayName) {
            if (notifications && notifications.error) {
                notifications.error('This is already your username', 'Error', 3000);
            }
            return;
        }
        
        if (newUsername.length < 3) {
            if (notifications && notifications.error) {
                notifications.error('Username must be at least 3 characters', 'Error', 3000);
            }
            return;
        }
        
        if (newUsername.length > 20) {
            if (notifications && notifications.error) {
                notifications.error('Username must be 20 characters or less', 'Error', 3000);
            }
            return;
        }

        if (!/^[a-zA-Z0-9_-]+$/.test(newUsername)) {
            if (notifications && notifications.error) {
                notifications.error('Username can only contain letters, numbers, underscores, and hyphens', 'Error', 3000);
            }
            return;
        }
        
        try {
            // Check if username is already taken
            const username_lower = newUsername.toLowerCase();
            const snapshot = await database.ref('users')
                .orderByChild('displayName_lower')
                .equalTo(username_lower)
                .once('value');
            
            if (snapshot.exists()) {
                // Check if it's taken by someone else
                let isTakenBySomeoneElse = false;
                snapshot.forEach(childSnapshot => {
                    if (childSnapshot.key !== currentUser.uid) {
                        isTakenBySomeoneElse = true;
                    }
                });
                
                if (isTakenBySomeoneElse) {
                    if (notifications && notifications.error) {
                        notifications.error('This username is already taken', 'Error', 3000);
                    }
                    return;
                }
            }
            
            // Update username in Firebase Auth
            await currentUser.updateProfile({ displayName: newUsername });
            
            // Update username in database
            await database.ref('users/' + currentUser.uid).update({
                displayName: newUsername,
                displayName_lower: newUsername.toLowerCase()
            });
            
            // Update UI
            updateUsernameDisplay(newUsername);
            
            // Show success message
            if (notifications && notifications.success) {
                notifications.success('Username changed successfully!', 'Success', 3000);
            }
            
        } catch (error) {
            console.error('Error changing username:', error);
            if (notifications && notifications.error) {
                notifications.error('Failed to change username. Please try again.', 'Error', 3000);
            }
        }
    }

    // Update username display in UI
    function updateUsernameDisplay(newUsername) {
        // Update header username
        const userNameElement = document.getElementById('user-name');
        if (userNameElement) {
            userNameElement.textContent = newUsername;
        }
        
        // Update avatar
        const userAvatarElement = document.getElementById('user-avatar');
        if (userAvatarElement) {
            const avatarText = newUsername && newUsername.length > 0 ? 
                newUsername.charAt(0).toUpperCase() : 'U';
            userAvatarElement.textContent = avatarText;
        }
        
        // Update allUsers object
        if (typeof allUsers !== 'undefined' && allUsers[currentUser.uid]) {
            allUsers[currentUser.uid].displayName = newUsername;
            allUsers[currentUser.uid].displayName_lower = newUsername.toLowerCase();
        }
        
        // Refresh contacts list
        if (typeof loadContactsList === 'function') {
            loadContactsList();
        }
    }

    // Random avatar
    function generateRandomAvatar() {
        const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#34495e', '#e67e22'];
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        const avatarPreview = document.getElementById('current-avatar');
        if (avatarPreview) {
            avatarPreview.style.background = randomColor;
        }
    }

    // Initialize event listeners when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        console.log('üîß Initializing settings panel...');
        
        // Settings button
        const settingsBtn = document.getElementById('settings-btn');
        if (settingsBtn) {
            console.log('üîß Settings button found, adding click listener');
            settingsBtn.addEventListener('click', (e) => {
                console.log('üîß Settings button clicked!', e);
                showSettingsPanel();
            });
        } else {
            console.error('üîß Settings button not found');
        }
        
        // Close button
        const closeSettings = document.getElementById('close-settings');
        if (closeSettings) {
            closeSettings.addEventListener('click', hideSettingsPanel);
        }
        
        // Save and reset buttons
        const saveSettingsBtn = document.getElementById('save-settings');
        if (saveSettingsBtn) {
            saveSettingsBtn.addEventListener('click', saveSettings);
        }
        
        const resetSettingsBtn = document.getElementById('reset-settings');
        if (resetSettingsBtn) {
            resetSettingsBtn.addEventListener('click', resetSettings);
        }
        
        // Username and avatar buttons
        const changeUsernameBtn = document.getElementById('change-username-btn');
        if (changeUsernameBtn) {
            changeUsernameBtn.addEventListener('click', changeUsername);
        }
        
        const randomAvatarBtn = document.getElementById('random-avatar-btn');
        if (randomAvatarBtn) {
            randomAvatarBtn.addEventListener('click', generateRandomAvatar);
        }
        
        // Font size slider
        const fontSizeSlider = document.getElementById('font-size-slider');
        const fontSizeValue = document.getElementById('font-size-value');
        if (fontSizeSlider && fontSizeValue) {
            fontSizeSlider.addEventListener('input', (e) => {
                fontSizeValue.textContent = e.target.value + 'px';
            });
        }
        
        // Close panel when clicking outside
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('settings-panel');
            if (panel && !panel.contains(e.target) && e.target.id !== 'settings-btn') {
                hideSettingsPanel();
            }
        });
        
        // Apply initial settings
        applySettings();
    });

    // Load users
    function loadUsers() {
        console.log("üë•üìã Loading users - Creating a new, clean slate.");
        return new Promise((resolve, reject) => {
            const usersRef = database.ref('users');
            
            usersRef.once('value').then(snapshot => {
                console.log("üë•üìã Received snapshot from Firebase.");
                
                allUsers = {}; // Reset the object
                snapshot.forEach(childSnapshot => {
                    const user = childSnapshot.val();
                    const userId = childSnapshot.key;
                    allUsers[userId] = user; // Populate the object
                });
                
                console.log("üë•üìã All users loaded. allUsers object now contains:", allUsers);
                console.table(allUsers);
                resolve();
            }).catch(error => {
                console.error("üë•üìã Failed to load users:", error);
                resolve(); // Still resolve to not break the chain
            });
        });
    }
    
    // Load all users
    function loadAllUsers() {
        database.ref('users').once('value', snapshot => {
            allUsers = {};
            snapshot.forEach(childSnapshot => {
                const user = childSnapshot.val();
                const userId = childSnapshot.key;
                allUsers[userId] = user;
            });
        });
    }
    
	// Load contacts list
	function loadContactsList() {
		console.log("üë•üìã Loading contacts list. The allUsers object contains:", allUsers);

		if (!recentChatsList) return; // Safety check

		recentChatsList.innerHTML = '';

		const now = Date.now();
		const twoMinutesAgo = now - (2 * 60 * 1000);
		const usersToShow = [];

		// Combine recent chats and all users into one list
		const allContactIds = new Set([...recentChats, ...Object.keys(allUsers)]);

		allContactIds.forEach(userId => {
			if (userId === currentUser.uid) return; // Don't add yourself
			if (isUserBanned(userId)) return; // Skip banned users

			const user = allUsers[userId];
			if (!user) return;

			// Filter out old guests
			if (user.isGuest && (!user.lastSeen || user.lastSeen < twoMinutesAgo)) {
				return;
			}

			usersToShow.push({
				userId: userId,
				user: user,
				isOnline: user.lastSeen && user.lastSeen > twoMinutesAgo,
				isLeader: window.leaderIds && window.leaderIds[userId],
				isAdmin: adminUsers[userId]
			});
		});

		// Sorting logic: Leaders first, then online status, then alphabetically
		usersToShow.sort((a, b) => {
			// 1. Leaders always come first
			if (a.isLeader && !b.isLeader) {
				return -1; // a comes before b
			}
			if (!a.isLeader && b.isLeader) {
				return 1; // b comes before a
			}
			
			// 2. If both are leaders or both are not leaders, check online status
			if (a.isOnline && !b.isOnline) {
				return -1; // a comes before b
			}
			if (!a.isOnline && b.isOnline) {
				return 1; // b comes before a
			}
			
			// 3. If both have same leader/online status, sort alphabetically
			return a.user.displayName.localeCompare(b.user.displayName);
		});

		if (usersToShow.length === 0) {
			const emptyMessage = document.createElement('div');
			emptyMessage.style.color = 'var(--text-secondary)';
			emptyMessage.style.fontSize = '12px';
			emptyMessage.style.padding = '10px';
			emptyMessage.textContent = 'No contacts found.';
			recentChatsList.appendChild(emptyMessage);
			return;
		}

		// Build the UI from the sorted array
		usersToShow.forEach(({ userId, user, isOnline, isLeader, isAdmin }) => {
			const chatItem = document.createElement('div');
			chatItem.classList.add('recent-chat-item');
			chatItem.dataset.userId = userId;
			
			// Add gradient classes based on status
			if (isOnline) {
				chatItem.classList.add('online');
			} else {
				chatItem.classList.add('offline');
			}
			
			// Add role-based gradient classes - prioritize leader over admin
			if (isLeader) {
				chatItem.classList.add('leader');
			} else if (isAdmin) {
				chatItem.classList.add('admin');
			}
			
			// Highlight the active chat
			if (privateChatUser && privateChatUser === userId) {
				chatItem.classList.add('active');
			}

			const chatInfo = document.createElement('div');
			chatInfo.classList.add('chat-info');

			const chatName = document.createElement('div');
			chatName.classList.add('chat-name');

			// Build display text
			let displayText = user.displayName || 'Unknown User';
			if (user.isGuest) {
				displayText += ' (Guest)';
			}

			// Add role indicators - prioritize leader over admin
			if (!displayText.includes('üëë') && window.leaderIds && window.leaderIds[userId]) {
				displayText += ' üëë'; // Leaders get crown
			} else if (!displayText.includes('‚ö°') && adminUsers[userId]) {
				displayText += ' ‚ö°'; // Admins get lightning bolt
			}

			chatName.textContent = displayText;

			chatInfo.appendChild(chatName);
			chatItem.appendChild(chatInfo);

			chatItem.addEventListener('click', () => {
				startPrivateChat(userId);
				// Close mobile sidebar after selecting chat
				if (window.innerWidth <= 480 && sidebar) {
					sidebar.classList.remove('open');
				}
			});

			recentChatsList.appendChild(chatItem);
		});
	}

    // Search for users
    function searchForUsers(searchTerm) {
        const chatSearchResults = document.getElementById('chat-search-results');
        if (!chatSearchResults) return;
        
        chatSearchResults.innerHTML = '';
        
        if (!searchTerm) {
            return;
        }
        
        const results = [];
        const lowerSearchTerm = searchTerm.toLowerCase();
        
        // Search through all users
        Object.keys(allUsers).forEach(userId => {
            if (userId === currentUser.uid) return; // Skip yourself
            
            // Skip banned users
            if (isUserBanned(userId)) return;
            
            const user = allUsers[userId];
            if (!user) return;
            
            const displayName = (user.displayName || 'Unknown User').toLowerCase();
            
            if (displayName.includes(lowerSearchTerm)) {
                results.push({ userId, user });
            }
        });
        
        // Display search results
        if (results.length === 0) {
            const noResults = document.createElement('div');
            noResults.style.color = '#9e9e9e';
            noResults.style.fontSize = '12px';
            noResults.style.padding = '8px';
            noResults.textContent = 'No users found';
            chatSearchResults.appendChild(noResults);
        } else {
            results.forEach(result => {
                const resultElement = document.createElement('div');
                resultElement.classList.add('chat-search-result-item');
                resultElement.dataset.userId = result.userId;
                
                const nameElement = document.createElement('div');
                nameElement.classList.add('chat-search-result-name');
                
                let displayText = result.user.displayName || 'Unknown User';
                if (result.user.isGuest) {
                    displayText += ' (Guest)';
                }
                if (window.leaderIds && window.leaderIds[result.userId]) {
                    displayText += ' üëë';
                }
                
                nameElement.textContent = displayText;
                
                const statusElement = document.createElement('div');
                statusElement.classList.add('chat-search-result-status');
                
                const now = Date.now();
                const fiveMinutesAgo = now - (5 * 60 * 1000);
                if (result.user.lastSeen && result.user.lastSeen > fiveMinutesAgo) {
                    statusElement.textContent = 'Online';
                } else {
                    statusElement.textContent = 'Offline';
                }
                
                resultElement.appendChild(nameElement);
                resultElement.appendChild(statusElement);
                
                resultElement.addEventListener('click', () => {
                    startPrivateChat(result.userId);
                    chatSearchResults.innerHTML = '';
                    const chatSearchInput = document.getElementById('search-user-input');
                    if (chatSearchInput) chatSearchInput.value = '';
                });
                
                chatSearchResults.appendChild(resultElement);
            });
        }
    }

    // Populate and show search modal
    function populateAndShowSearchModal() {
        console.log("üîç Populating search modal from existing user list.");
        console.log("üîç DEBUG: The allUsers object contains:", allUsers);
        if (!searchResults) return; // Added: Null check
        
        searchResults.innerHTML = '';

        const now = Date.now();
        const twoMinutesAgo = now - (2 * 60 * 1000);
        const usersToShow = [];

        Object.keys(allUsers).forEach(userId => {
            if (userId === currentUser.uid) return; // Skip yourself
            if (isUserBanned(userId)) return; // Skip banned users

            const user = allUsers[userId];
            if (!user) return;

            // Filter out old guests
            if (user.isGuest && (!user.lastSeen || user.lastSeen < twoMinutesAgo)) {
                return;
            }

            usersToShow.push({
                userId: userId,
                user: user,
                isOnline: user.lastSeen && user.lastSeen > twoMinutesAgo
            });
        });

        // Sort: Online users first (A-Z), then offline users (A-Z)
        usersToShow.sort((a, b) => {
            // Online users come before offline users
            if (a.isOnline && !b.isOnline) return -1;
            if (!a.isOnline && b.isOnline) return 1;
            
            // If both have the same online status, sort alphabetically A-Z
            return a.user.displayName.localeCompare(b.user.displayName);
        });

        if (usersToShow.length === 0) {
            searchResults.innerHTML = '<div style="padding: 10px; color: #9e9e9e;">No users found. Try refreshing.</div>';
            if (newChatModal) newChatModal.style.display = 'block';
            return;
        }

        // Build the UI from the sorted array
        usersToShow.forEach(({ userId, user, isOnline }) => {
            const userElement = document.createElement('div');
            userElement.classList.add('search-result-item');
            userElement.dataset.userId = userId;
            
            const nameElement = document.createElement('div');
            nameElement.classList.add('search-result-name');
            
            let displayText = user.displayName || 'Unknown User';
            if (user.isGuest) {
                displayText += ' (Guest)';
            }
            if (window.leaderIds && window.leaderIds[userId]) {
                displayText += ' üëë';
            }
            
            nameElement.textContent = displayText;
            
            const statusElement = document.createElement('div');
            statusElement.classList.add('search-result-status');
            
            userElement.appendChild(nameElement);
            
            userElement.addEventListener('click', () => {
                startPrivateChat(userId);
                if (newChatModal) newChatModal.style.display = 'none';
            });
            
            searchResults.appendChild(userElement);
        });

        if (newChatModal) newChatModal.style.display = 'block';
    }

	// Start private chat with a user
	function startPrivateChat(userId) {
		// Clear typing indicators
		clearAllTypingIndicators();
		
		// Check if user is banned
		if (isUserBanned(userId)) {
			notifications.error("this is a banned user, bro. u can't chat with them now.", 'user not available', '6000');
			return;
		}
		
		privateChatUser = userId;
		
		// Add to recent chats
		addToRecentChats(userId);
        
        database.ref('users/' + userId).once('value', snapshot => {
            if (snapshot.exists()) {
                const user = snapshot.val();
                if (currentRoomName) {
                    currentRoomName.textContent = `${user.displayName || 'Unknown User'}`;
                }
                
                // Update room selection
                document.querySelectorAll('.room-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Refresh the entire contacts list to show all users again
                loadContactsList();
                
                // Load private messages
                loadMessages();
                setupTypingListeners();
            }
        });
    }

    // Cleanup function for stale users
    function cleanupStaleUsers() {
        const now = Date.now();
        const fiveMinutesAgo = now - (5 * 60 * 1000); // 5 minutes ago
        
        database.ref('users').once('value', snapshot => {
            snapshot.forEach(childSnapshot => {
                const user = childSnapshot.val();
                const userId = childSnapshot.key;
                
                // If user hasn't been seen in the last 5 minutes and is marked as online, remove the online status
                if (user.lastSeen && user.lastSeen < fiveMinutesAgo && user.isOnline) {
                    console.log(`User ${userId} is stale but not online. No action needed.`);
                    return;
                }
                
                // If user is a guest and hasn't been seen in the last 2 minutes, remove them
                if (user.isGuest && (!user.lastSeen || user.lastSeen < twoMinutesAgo)) {
                    console.log(`Removing stale guest user: ${userId}`);
                    database.ref('users/' + userId).remove();
                }
            });
        });
    }

    // ====================================================================================================
    // RECENT CHATS FUNCTIONS
    // ====================================================================================================
    
    // Load recent chats
    function loadRecentChats() {
        if (!currentUser) return; // Safety check
        
        database.ref('recentChats/' + currentUser.uid).once('value', snapshot => {
            recentChats = [];
            if (snapshot.exists()) {
                snapshot.forEach(childSnapshot => {
                    recentChats.push(childSnapshot.key);
                });
            }
            updateRecentChatsUI();
        });
    }

    // Add user to recent chats
    function addToRecentChats(userId) {
        if (!recentChats.includes(userId)) {
            recentChats.unshift(userId);
            // Keep only the last 10 recent chats
            if (recentChats.length > 10) {
                recentChats = recentChats.slice(0, 10);
            }
            
            // Update in database
            const updates = {};
            recentChats.forEach((id, index) => {
                updates[id] = index;
            });
            database.ref('recentChats/' + currentUser.uid).set(updates);
        }
    }

    // Update recent chats UI
    function updateRecentChatsUI() {
        if (!recentChatsList) return; // Added: Null check
        
        recentChatsList.innerHTML = '';
        
        if (recentChats.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.style.color = '#9e9e9e';
            emptyMessage.style.fontSize = '12px';
            emptyMessage.style.padding = '10px';
            emptyMessage.textContent = 'No recent chats';
            recentChatsList.appendChild(emptyMessage);
            return;
        }
        
        recentChats.forEach(userId => {
            // Skip banned users
            if (isUserBanned(userId)) return;
            
            database.ref('users/' + userId).once('value', snapshot => {
                if (snapshot.exists()) {
                    const user = snapshot.val();
                    
                    if (user.isGuest) {
                        const now = Date.now();
                        const twoMinutesAgo = now - (2 * 60 * 1000);
                        
                        // Skip this old guest
                        if (!user.lastSeen || user.lastSeen < twoMinutesAgo) {
                            return;
                        }
                    }
                
                    const chatItem = document.createElement('div');
                    chatItem.classList.add('recent-chat-item');
                    chatItem.dataset.userId = userId;
                    chatItem.dataset.guest = user.isGuest;
                    
                    if (privateChatUser === userId) {
                        chatItem.classList.add('active');
                    }
                    
                    const chatInfo = document.createElement('div');
                    chatInfo.classList.add('chat-info');
                    
                    const chatName = document.createElement('div');
                    chatName.classList.add('chat-name');
                    
                    let displayText = user.displayName || 'Unknown User';
                    if (user.isGuest) {
                        displayText += ' (Guest)';
                    }
                    
                    chatName.textContent = displayText;
                    
                    chatInfo.appendChild(chatName);
                    chatItem.appendChild(chatInfo);
                    
                    recentChatsList.appendChild(chatItem);
                }
            });
        });
    }

    // ====================================================================================================
    // ADMIN FUNCTIONS
    // ====================================================================================================
    
    // Set up admin-specific listeners
    function setupAdminListeners() {
        if (!isCurrentUserAdmin()) return;
        
        // Listen for changes to banned users
        database.ref('bannedUsers').on('value', snapshot => {
            bannedUsers = snapshot.val() || {};
            loadContactsList();
        });
        
        // Listen for changes to admin users
        database.ref('adminUsers').on('value', snapshot => {
            adminUsers = snapshot.val() || {};
            loadContactsList();
        });
    }
    
    // Refresh banned users list (for leaders/admins)
    async function refreshBannedUsers() {
        if (!isCurrentUserAdmin() && !isCurrentUserLeader()) {
            notifications.error("You don't have permission to refresh banned users", 'Access Denied', 5000);
            return;
        }
        
        try {
            console.log("üîß Refreshing banned users list...");
            const bannedSnapshot = await database.ref('bannedUsers').once('value');
            bannedUsers = bannedSnapshot.val() || {};
            console.log("üîß Refreshed banned users:", bannedUsers);
            
            // Update UI
            updateAdminUserSelect();
            loadContactsList();
            
            notifications.success("Banned users list refreshed", 'Success', 3000);
        } catch (error) {
            console.error("üîß Error refreshing banned users:", error);
            
            if (error.code === 'PERMISSION_DENIED') {
                notifications.error("Permission denied. Your Firebase security rules may need updating.", 'Security Rules Error', 5000);
            } else {
                notifications.error("Failed to refresh banned users list", 'Error', 5000);
            }
        }
    }

    // ====================================================================================================
    // MESSAGE MANAGEMENT FUNCTIONS
    // ====================================================================================================
    
    // Message Listener Manager - Fixed to properly handle listeners
    const MessageListenerManager = {
        currentPath: null,
        currentRef: null,
        listeners: [], // Track all listeners

        detach: function() {
            console.log("üí¨ü¶ªüë®‚Äçüíº Detaching listener for path:", this.currentPath);
            
            if (this.currentRef) {
                this.currentRef.off();
                this.currentRef = null;
            }
            this.currentPath = null;
            
            // Clear all listeners
            this.listeners = [];
        },
        
        // Add this reset method to clear everything
        reset: function() {
            console.log("üí¨ü¶ªüë®‚Äçüíº Resetting all state");
            this.detach();
            this.currentPath = null;
            this.currentRef = null;
            this.listeners = [];
        },
        
        attach: function(path, onMessage) {
            // If we're already listening to this exact path, do nothing to prevent duplicates.
            if (this.currentPath === path && this.currentRef) {
                console.log("üí¨ü¶ªüë®‚Äçüíº Already listening to", path, ". Skipping re-attach.");
                return;
            }

            // If we were listening to a different path, detach that listener first.
            if (this.currentPath) {
                this.detach();
            }

            this.currentPath = path;
            this.currentRef = database.ref(path);
            
            console.log("üí¨ü¶ªüë®‚Äçüíº Attaching NEW listener to path:", path);
            
            // Create a callback that we can track
            const messageCallback = (snapshot) => {
                if (snapshot.exists()) {
                    onMessage(snapshot.val());
                }
            };
            
            // Store the callback for later removal
            this.listeners.push({
                ref: this.currentRef,
                callback: messageCallback
            });
            
            this.currentRef.on('child_added', messageCallback);
        }
    };

	// Display a message
	function displayMessage(message) {
		const senderId = message.userId || message.senderId;
		
		// Check if message object exists
		if (!message) {
			console.error("Invalid message object:", message);
			return;
		}
		
		// Only play sound if message is NOT from current user AND tab is inactive
		if (senderId !== currentUser.uid && !isTabActive()) {
			playNotificationSound();
		}
		
		// Check if sender is banned
		if (isUserBanned(senderId)) {
			console.log("Message from banned user, not displaying.");
			return;
		}

		const messagesContainer = document.getElementById('messages');
		if (!messagesContainer) {
			console.error("Could not find the messages container element!");
			return;
		}

		const messageElement = document.createElement('div');
		messageElement.classList.add('message');
		messageElement.dataset.messageId = message.messageId || message.key || 'unknown';
		messageElement.dataset.timestamp = message.timestamp;
		
		// Check if message is from current user
		const isCurrentUser = senderId === currentUser.uid;
		if (isCurrentUser) {
			messageElement.classList.add('current-user');
		}
		
		// Add guest status if it exists
		if (message.isGuest) {
			messageElement.setAttribute('data-guest', 'true');
		}

		// Add role indicator - prioritize leader over admin
		if (window.leaderIds && window.leaderIds[senderId]) {
			messageElement.classList.add('leader-message');
		} else if (adminUsers[senderId]) {
			messageElement.classList.add('admin-message');
		}

		// Handle replies
		if (message.replyTo) {
			messageElement.classList.add('is-reply');
			
			const repliedToElement = document.createElement('div');
			repliedToElement.classList.add('replied-to-message');
			repliedToElement.innerHTML = `<strong>${message.replyTo.username || message.replyTo.senderName}:</strong> ${message.replyTo.text}`;
			messageElement.appendChild(repliedToElement);
		}
		
		// Create username element with role indicators
		const usernameElement = document.createElement('div');
		usernameElement.classList.add('username');

		let displayName = message.username || message.senderName || 'Unknown User';

		// Add role indicators - prioritize leader over admin
		if (!displayName.includes('üëë') && window.leaderIds && window.leaderIds[senderId]) {
			displayName += ' üëë'; // Leaders get crown
		} else if (!displayName.includes('‚ö°') && adminUsers[senderId]) {
			displayName += ' ‚ö°'; // Admins get lightning bolt
		}

		usernameElement.textContent = displayName;
		messageElement.appendChild(usernameElement);
		
		// Create content element
		const contentElement = document.createElement('div');
		contentElement.classList.add('content');

		// Check message type and render accordingly
		if (message.type === 'voice') {
			const audioPlayer = document.createElement('audio');
			audioPlayer.src = message.content;
			audioPlayer.controls = true;
			audioPlayer.classList.add('voice-player');
			contentElement.appendChild(audioPlayer);
		} else {
			const textElement = document.createElement('div');
			textElement.classList.add('text');
			textElement.textContent = message.text || message.content;
			contentElement.appendChild(textElement);
		}
		messageElement.appendChild(contentElement);
		
		// Create timestamp element
		const timeElement = document.createElement('div');
		timeElement.classList.add('time');
		
		const date = new Date(message.timestamp);
		timeElement.textContent = `${formatTime(date)} ‚Ä¢ ${formatShortDate(date)}`;
		messageElement.appendChild(timeElement);
		
		// Add reply button for non-current users
		if (!isCurrentUser) {
			const replyButtonContainer = document.createElement('div');
			replyButtonContainer.classList.add('reply-button-container');
			
			const replyButton = document.createElement('button');
			replyButton.classList.add('reply-button');
			replyButton.textContent = 'Reply';
			
			// Add the click event listener to initiate the reply
			replyButton.addEventListener('click', () => {
				setReplyingTo({
					id: senderId,
					username: message.username || message.senderName,
					text: message.text
				});
			});
			
			replyButtonContainer.appendChild(replyButton);
			messageElement.appendChild(replyButtonContainer);
		}
		
		// Add message to container
		messagesContainer.appendChild(messageElement);
		
		// Scroll to bottom
		messagesContainer.scrollTop = messagesContainer.scrollHeight;
	}

    // Send a message
    async function sendMessage() {
        console.log("üí¨‚§¥Ô∏è sendMessage function STARTED =====");
		
	    // Prevent sending other messages while recording or uploading
		if (isRecording || isUploading) {
			notifications.warning("Please wait for the voice message to finish processing.", "Please Wait");
			return;
		}
        
        const messageText = messageInput.value.trim();
        console.log("üí¨‚§¥Ô∏è Message text:", messageText);
        console.log("üí¨‚§¥Ô∏è Current user:", currentUser);
        console.log("üí¨‚§¥Ô∏è Replying to message:", replyingTo);
        
        // Check if current user is banned
        const isBanned = await isCurrentUserBanned();
        if (isBanned) {
            console.error("üí¨‚§¥Ô∏è‚ùå Cannot send message. User is banned.");
            notifications.error("u can't send messages, bro. ur banned.", "Can't do that", 6000);
            
            // Show banned notification
            try {
                const banSnapshot = await database.ref('bannedUsers/' + currentUser.uid).once('value');
                if (banSnapshot.exists()) {
                    const banData = banSnapshot.val();
                    showBannedNotification(banData.reason || 'No reason provided.');
                }
            } catch (error) {
                console.error("Error fetching ban details:", error);
                showBannedNotification('No reason provided.');
            }
            
            return;
        }
        
        // Check if current user has verified their email (if not a guest)
        if (!currentUser.isAnonymous && !currentUser.emailVerified) {
            notifications.error("ur email is unverified, bro. verify it first, then try sending a message.", "Can't do that", '6000');
            return;
        }
        
        if (!currentUser) {
            console.error("üí¨‚§¥Ô∏è‚ùå ERROR: Cannot send message. User is not logged in.");
            notifications.error("u gotta be logged in to send messages, bro.", "Can't do that (yet)", 6000);
            return;
        }
        
        if (!messageText && !selectedImage) {
            console.warn("üí¨‚§¥Ô∏è‚ö†Ô∏è No content to send");
            return;
        }
        
        console.log("üí¨‚§¥Ô∏è‚úÖ Checks passed. Attempting to send message...");
        const timestamp = Date.now();
        
        let messageRef;
        let messageData;
        
        // Standardize message data structure
        const baseMessageData = {
            senderId: currentUser.uid,
			receiverId: privateChatUser,
            senderName: currentUser.displayName || 'User',
            text: messageText,
            timestamp: timestamp,
            isGuest: currentUser.isAnonymous,
            replyTo: replyingTo ? {
                text: replyingTo.text,
                username: replyingTo.username || replyingTo.senderName,
                id: replyingTo.id
            } : null
        };
        
        // Determine message location and prepare data
        if (privateChatUser) {
            // Private message
            const chatId = [currentUser.uid, privateChatUser].sort().join('_');
            messageRef = database.ref('privateMessages/' + chatId);
            messageData = baseMessageData;
        } else {
            // Public room message
            messageRef = database.ref('messages/' + currentRoom);
            messageData = {...baseMessageData, userId: currentUser.uid, username: currentUser.displayName || 'User'};
        }
        
        console.log("üîß Message data to be sent:", messageData);
        
        // Send the message to Firebase
        const messagePromise = messageRef.push(messageData);
        
        // Handle the response
        messagePromise
            .then(() => {
                console.log("‚úÖ SUCCESS: Message was successfully sent to Firebase!");
                
                // Clear input and states
                if (messageInput) messageInput.value = '';
                cancelReply();
                stopTyping();
                
                // Update recent chats if private message
                if (privateChatUser) {
                    addToRecentChats(privateChatUser);
                }
            })
            .catch((error) => {
                console.error("‚ùå ERROR: Firebase rejected the message. Error details:", error);
                notifications.error("couldn't send that message, bro. check the console for details.", 'Something Went Wrong', '8000');
            });
    }

    // Load messages
    function loadMessages() {
        console.log("üí¨‚úîÔ∏è loadMessages has been called.");
        
        const messagesContainer = document.getElementById('messages');
        if (!messagesContainer) {
            console.error("üí¨‚ùå Could not find the messages container element!");
            return;
        }
        
        // Clear existing messages
        messagesContainer.innerHTML = '';
        
        // Show loading indicator
        const loadingContainer = document.getElementById('messages-loading-container');
        if (loadingContainer) {
            loadingContainer.style.display = 'flex';
        }
        
        // Determine the path based on whether it's a private chat or room
        let path;
        if (privateChatUser) {
            const chatId = [currentUser.uid, privateChatUser].sort().join('_');
            path = 'privateMessages/' + chatId;
        } else {
            path = 'messages/' + currentRoom;
        }
        
        console.log("üí¨ü¶ª Setting up listener for path:", path);
        
        // Force detach any existing listener before attaching new one
        MessageListenerManager.detach();
        
        // Use the MessageListenerManager to handle messages
        MessageListenerManager.attach(
            path,
            (message) => {
                // Hide loading indicator after first message loads
                if (loadingContainer) {
                    loadingContainer.style.display = 'none';
                }
                displayMessage(message);
            }
        );
    }
    
    // Set replying to message
    function setReplyingTo(message) {
        replyingTo = message;
        
        // Update the message input area to show the preview
        const messageInputContainer = document.getElementById('message-input-container');
        if (!messageInputContainer) return; // Add this line
        
        // Remove any existing reply preview
        const existingPreview = messageInputContainer.querySelector('.reply-preview');
        if (existingPreview) {
            existingPreview.remove();
        }
        
        // Create the new reply preview element
        const replyPreview = document.createElement('div');
        replyPreview.classList.add('reply-preview');
        
        const replyText = document.createElement('span');
        replyText.textContent = `Replying to ${message.username || message.senderName}: "${message.text}"`;
        
        const cancelButton = document.createElement('button');
        cancelButton.classList.add('cancel-reply-btn');
        cancelButton.textContent = '‚úï';
        
        replyPreview.appendChild(replyText);
        replyPreview.appendChild(cancelButton);
        
        // Insert the preview before the input field
        const inputWithButton = messageInputContainer.querySelector('.input-with-button');
        messageInputContainer.insertBefore(replyPreview, inputWithButton);
        
        // Focus the input field
        if (messageInput) messageInput.focus();
        
        // Add click handler to cancel the reply
        cancelButton.addEventListener('click', cancelReply);
    }

    // Cancel reply
    function cancelReply() {
        replyingTo = null;
        
        // Remove the reply preview
        const replyPreview = document.querySelector('.reply-preview');
        if (replyPreview) {
            replyPreview.remove();
        }
        
        // Focus the input field
        if (messageInput) messageInput.focus();
    }
	
		// ====================================================================================================
		// CALLING FUNCTIONALITY
		// ====================================================================================================

		// --- WebRTC Configuration ---
		const configuration = {
			iceServers: [
				{ urls: 'stun:stun.l.google.com:19302' },
				{ urls: 'stun:stun1.l.google.com:19302' }
			]
		};

		// --- Main Calling Functions ---

		// Initialize a call (outgoing)
		async function initiateCall(userId) {
			if (!currentUser || !userId || userId === currentUser.uid) {
				notifications.error("Invalid user for call.", "Error");
				return;
			}

			const user = allUsers[userId];
			if (!user) {
				notifications.error("User not found.", "Error");
				return;
			}

			// Check if user is online
			const now = Date.now();
			const twoMinutesAgo = now - (2 * 60 * 1000);
			if (!user.lastSeen || user.lastSeen < twoMinutesAgo) {
				notifications.warning(`${user.displayName} is offline.`, "Cannot Call");
				return;
			}

			// Set up local media
			try {
				localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
				if (localVideo) {
					localVideo.srcObject = localStream;
				}
			} catch (error) {
				console.error("Error accessing media devices:", error);
				notifications.error("Could not access camera or microphone.", "Media Error");
				return;
			}

			// Create peer connection
			createPeerConnection();

			// Add local stream to peer connection
			localStream.getTracks().forEach(track => {
				peerConnection.addTrack(track, localStream);
			});

			// Create offer
			const offer = await peerConnection.createOffer();
			await peerConnection.setLocalDescription(offer);

			// Send call offer to the other user via Firebase
			const callData = {
				caller: currentUser.uid,
				callerName: currentUser.displayName,
				receiver: userId,
				offer: offer,
				timestamp: firebase.database.ServerValue.TIMESTAMP
			};

			currentCall = await database.ref('calls').push(callData);
			isCallActive = true;

			// Show call UI
			showActiveCallUI(user.displayName);

			// Listen for call end
			currentCall.on('value', (snapshot) => {
				const data = snapshot.val();
				if (!data || data.status === 'ended') {
					endCall();
				}
			});
		}

		// Handle an incoming call
		async function handleIncomingCall(callId, callData) {
			incomingCallData = { id: callId, ...callData };

			const callerUser = allUsers[callData.caller];
			if (!callerUser) return;

			// Show incoming call UI
			showIncomingCallUI(callerUser.displayName);

			// Auto-reject after 30 seconds if not answered
			setTimeout(() => {
				if (incomingCallData && incomingCallData.id === callId) {
					rejectCall();
				}
			}, 30000);
		}

		// Accept an incoming call
		async function acceptCall() {
			if (!incomingCallData) return;

			const { id, offer, caller } = incomingCallData;

			// Set up local media
			try {
				localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
				if (localVideo) {
					localVideo.srcObject = localStream;
				}
			} catch (error) {
				console.error("Error accessing media devices:", error);
				notifications.error("Could not access camera or microphone.", "Media Error");
				rejectCall();
				return;
			}

			// Create peer connection
			createPeerConnection();

			// Add local stream to peer connection
			localStream.getTracks().forEach(track => {
				peerConnection.addTrack(track, localStream);
			});

			// Set remote description from offer
			await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

			// Create answer
			const answer = await peerConnection.createAnswer();
			await peerConnection.setLocalDescription(answer);

			// Update call in Firebase with answer
			await database.ref(`calls/${id}`).update({
				answer: answer,
				status: 'connected'
			});

			isCallActive = true;
			currentCall = database.ref(`calls/${id}`);

			// Show active call UI
			const callingUser = allUsers[incomingCallData.caller];
			showActiveCallUI(callingUser.displayName);

			// Listen for call end
			currentCall.on('value', (snapshot) => {
				const data = snapshot.val();
				if (!data || data.status === 'ended') {
					endCall();
				}
			});

			incomingCallData = null;
		}

		// Reject an incoming call
		async function rejectCall() {
			if (!incomingCallData) return;

			const { id } = incomingCallData;

			// Update call status in Firebase
			await database.ref(`calls/${id}`).update({
				status: 'rejected'
			});

			// Hide call UI
			hideCallUI();

			incomingCallData = null;
		}

		// End an active call
		async function endCall() {
			if (currentCall) {
				// Update call status in Firebase
				await currentCall.update({
					status: 'ended'
				});
				currentCall = null;
			}

			// Stop local stream
			if (localStream) {
				localStream.getTracks().forEach(track => track.stop());
				localStream = null;
			}

			// Stop remote stream
			if (remoteStream) {
				remoteStream.getTracks().forEach(track => track.stop());
				remoteStream = null;
			}

			// Close peer connection
			if (peerConnection) {
				peerConnection.close();
				peerConnection = null;
			}

			// Clear call timer
			if (callTimerInterval) {
				clearInterval(callTimerInterval);
				callTimerInterval = null;
			}

			// Hide call UI
			hideCallUI();

			isCallActive = false;
			callStartTime = null;
		}

		// --- WebRTC Helper Functions ---

		function createPeerConnection() {
			peerConnection = new RTCPeerConnection(configuration);

			// Handle ICE candidates
			peerConnection.onicecandidate = (event) => {
				if (event.candidate && currentCall) {
					currentCall.child('iceCandidates').push(event.candidate);
				}
			};

			// Handle remote stream
			peerConnection.ontrack = (event) => {
				remoteStream = event.streams[0];
				if (remoteVideo) {
					remoteVideo.srcObject = remoteStream;
				}
			};
		}

		// --- Call UI Functions ---

		function showIncomingCallUI(callerName) {
			if (!callModal) return;

			const modalContent = callModal.querySelector('.modal-content');
			modalContent.innerHTML = `
				<div class="incoming-call-container">
					<div class="user-avatar">${callerName ? callerName.charAt(0).toUpperCase() : '?'}</div>
					<h2>${callerName || 'Unknown User'}</h2>
					<p>Incoming call...</p>
					<div class="incoming-call-controls">
						<button class="call-btn accept" id="accept-call-btn">‚úì</button>
						<button class="call-btn end-call" id="reject-call-btn">‚úï</button>
					</div>
				</div>
			`;

			// Re-attach event listeners
			document.getElementById('accept-call-btn').addEventListener('click', acceptCall);
			document.getElementById('reject-call-btn').addEventListener('click', rejectCall);

			callModal.style.display = 'block';
		}

		function showActiveCallUI(callerName) {
			if (!callModal) return;

			callStartTime = Date.now();
			startCallTimer();

			const modalContent = callModal.querySelector('.modal-content');
			modalContent.innerHTML = `
				<div class="call-header">
					<div class="call-user-info">
						<h3>${callerName || 'Unknown User'}</h3>
						<p id="call-timer">00:00</p>
					</div>
				</div>
				<div class="video-container">
					<video id="remote-video" class="video-element" autoplay></video>
					<video id="local-video" class="video-element" autoplay muted></video>
				</div>
				<div class="call-controls">
					<button class="call-btn mic-active" id="toggle-mic-btn">üé§</button>
					<button class="call-btn video-active" id="toggle-video-btn">üìπ</button>
					<button class="call-btn end-call" id="end-call-btn">üìû</button>
				</div>
			`;

			// Re-attach event listeners and update DOM references
			document.getElementById('end-call-btn').addEventListener('click', endCall);
			document.getElementById('toggle-mic-btn').addEventListener('click', toggleMic);
			document.getElementById('toggle-video-btn').addEventListener('click', toggleVideo);

			// Update global DOM element references
			localVideo = document.getElementById('local-video');
			remoteVideo = document.getElementById('remote-video');
			callTimer = document.getElementById('call-timer');

			// Set local video stream if already available
			if (localVideo && localStream) {
				localVideo.srcObject = localStream;
			}

			callModal.style.display = 'block';
		}

		function hideCallUI() {
			if (callModal) {
				callModal.style.display = 'none';
			}
		}

		function startCallTimer() {
			if (!callTimer) return;

			callTimerInterval = setInterval(() => {
				const now = Date.now();
				const duration = Math.floor((now - callStartTime) / 1000);
				const minutes = Math.floor(duration / 60).toString().padStart(2, '0');
				const seconds = (duration % 60).toString().padStart(2, '0');
				callTimer.textContent = `${minutes}:${seconds}`;
			}, 1000);
		}

		// --- Call Control Functions ---

		function toggleMic() {
			if (!localStream) return;

			const audioTrack = localStream.getAudioTracks()[0];
			if (audioTrack) {
				audioTrack.enabled = !audioTrack.enabled;
				const micBtn = document.getElementById('toggle-mic-btn');
				if (micBtn) {
					micBtn.className = audioTrack.enabled ? 'call-btn mic-active' : 'call-btn mic-muted';
					micBtn.textContent = audioTrack.enabled ? 'üé§' : 'üîá';
				}
			}
		}

		function toggleVideo() {
			if (!localStream) return;

			const videoTrack = localStream.getVideoTracks()[0];
			if (videoTrack) {
				videoTrack.enabled = !videoTrack.enabled;
				const videoBtn = document.getElementById('toggle-video-btn');
				if (videoBtn) {
					videoBtn.className = videoTrack.enabled ? 'call-btn video-active' : 'call-btn video-disabled';
					videoBtn.textContent = videoTrack.enabled ? 'üìπ' : 'üìµ';
				}
			}
		}

		// --- Firebase Listeners for Call Signaling ---

		function setupCallListeners() {
			// Listen for incoming calls
			database.ref('calls').orderByChild('receiver').equalTo(currentUser.uid).on('child_added', (snapshot) => {
				const callData = snapshot.val();
				if (callData.status === 'calling') {
					handleIncomingCall(snapshot.key, callData);
				}
			});

			// Listen for call answers and ICE candidates
			database.ref('calls').on('child_changed', (snapshot) => {
				const callData = snapshot.val();
				
				// Handle answer to our outgoing call
				if (isCallActive && currentCall && currentCall.key === snapshot.key && callData.answer) {
					peerConnection.setRemoteDescription(new RTCSessionDescription(callData.answer));
				}
			});

			// Listen for ICE candidates
			database.ref('calls').on('child_added', (snapshot) => {
				const callData = snapshot.val();
				
				// Handle ICE candidates for our call
				if (isCallActive && currentCall && currentCall.key === snapshot.key && callData.iceCandidates) {
					Object.values(callData.iceCandidates).forEach(candidate => {
						peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
					});
				}
			});
		}

		// --- Add Call Button to User List ---

		function addCallButtonToUserList() {
			const recentChatItems = document.querySelectorAll('.recent-chat-item');
			
			recentChatItems.forEach(item => {
				const userId = item.dataset.userId;
				
				// Skip if it's the current user or if button already exists
				if (userId === currentUser.uid || item.querySelector('.sidebar-call-btn')) {
					return;
				}

				const user = allUsers[userId];
				if (!user) return;

				// Check if user is online
				const now = Date.now();
				const twoMinutesAgo = now - (2 * 60 * 1000);
				const isOnline = user.lastSeen && user.lastSeen > twoMinutesAgo;

				if (isOnline) {
					const callBtn = document.createElement('button');
					callBtn.className = 'sidebar-call-btn';
					callBtn.textContent = 'üìû';
					callBtn.title = 'Start a call';
					callBtn.addEventListener('click', () => initiateCall(userId));

					const chatInfo = item.querySelector('.chat-info');
					if (chatInfo) {
						chatInfo.appendChild(callBtn);
					}
				}
			});
		}

		// --- Initialize Call Listeners ---

		// Call setupCallListeners when user is set up
		const originalSetupUser = setupUser;
		setupUser = function() {
			originalSetupUser().then(() => {
				setupCallListeners();
			});
		};

		// Add call buttons when contacts list is loaded
		const originalLoadContactsList = loadContactsList;
		loadContactsList = function() {
			originalLoadContactsList();
			addCallButtonToUserList();
		};

    // ====================================================================================================
    // IMAGE UPLOAD FUNCTIONS
    // ====================================================================================================
    
    // Format file size
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Show image preview
    function showImagePreview(file) {
        if (!previewContainer || !preview || !imageName || !imageSize) return; // Added: Null check
        
        // Create preview URL
        const reader = new FileReader();
        reader.onload = (e) => {
            preview.src = e.target.result;
            imageName.textContent = file.name;
            imageSize.textContent = formatFileSize(file.size);
            previewContainer.style.display = 'block';
        };
        
        reader.readAsDataURL(file);
    }

    // Cancel image upload
    function cancelImageUpload() {
        selectedImage = null;
        if (previewContainer) previewContainer.style.display = 'none';
        if (imageInput) imageInput.value = '';
    }

    // Upload image to Firebase Storage and return URL
    async function uploadImageAndGetUrl(file) {
        return new Promise((resolve, reject) => {
            try {
                // Validate file
                if (!file.type.startsWith('image/')) {
                    reject(new Error('Invalid file type. Please select an image.'));
                    return;
                }
                
                if (file.size > 5 * 1024 * 1024) { // 5MB limit
                    reject(new Error('Image size must be less than 5MB'));
                    return;
                }
                
                // Create unique filename
                const timestamp = Date.now();
                const fileName = `images/${currentUser.uid}/${timestamp}_${file.name}`;
                
                // Upload to Firebase Storage
                const storageRef = storage.ref(fileName);
                const uploadTask = storageRef.put(file);
                
                // Show progress
                showUploadProgress();
                
                uploadTask.on('state_changed', (snapshot) => {
                    const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                    updateUploadProgress(progress);
                });
                
                uploadTask.then((snapshot) => {
                    hideUploadProgress();
                    return snapshot.ref.getDownloadURL();
                })
                .then((downloadURL) => {
                    console.log("üîó Got download URL:", downloadURL);
                    resolve(downloadURL);
                })
                .catch((error) => {
                    console.error("‚ùå Storage error:", error);
                    reject(error);
                });
                
            } catch (error) {
                console.error("‚ùå Upload error:", error);
                reject(error);
            }
        });
    }

    // Update upload progress bar
    function updateUploadProgress(percentage) {
        const progressBar = document.querySelector('.upload-progress-bar');
        if (progressBar) {
            progressBar.style.width = `${Math.min(percentage, 100)}%`;
        }
    }

    // Show upload progress
    function showUploadProgress() {
        const messageInputContainer = document.getElementById('message-input-container');
        if (!messageInputContainer) return; // Added: Null check
        
        const progressContainer = document.createElement('div');
        progressContainer.className = 'upload-progress';
        progressContainer.innerHTML = '<div class="upload-progress-bar"></div>';
        
        messageInputContainer.appendChild(progressContainer);
    }

    // Hide upload progress
    function hideUploadProgress() {
        const progressContainer = document.querySelector('.upload-progress');
        if (progressContainer) {
            progressContainer.remove();
        }
    }

    // Setup image upload functionality
    function setupImageUpload() {
        if (!imageInput || !uploadBtn || !previewContainer || !cancelBtn) return; // Added: Null check
        
        // Upload button click
        uploadBtn.addEventListener('click', () => {
            imageInput.click();
        });
        
        // File selection
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            // Validate file
            if (!file.type.startsWith('image/')) {
                notifications.error('Please select an image file', 'Invalid File', 5000);
                return;
            }
            
            if (file.size > 5 * 1024 * 1024) { // 5MB limit
                notifications.error('Image must be smaller than 5MB', 'File Too Large', 5000);
                return;
            }
            
            selectedImage = file;
            showImagePreview(file);
        });
        
        // Cancel button
        cancelBtn.addEventListener('click', cancelImageUpload);
    }

    // ====================================================================================================
    // TYPING INDICATOR FUNCTIONS
    // ====================================================================================================
    
	// Handle typing indicator
	function handleTyping() {
		if (!currentUser) return;
		
		// NEW: Clear typing status when switching chats
		clearAllTypingIndicators();
		
		if (!isTyping) {
			isTyping = true;
			
			let typingRef;
			
			if (privateChatUser) {
				// Private typing
				const chatId = [currentUser.uid, privateChatUser].sort().join('_');
				typingRef = database.ref('typing/' + chatId + '/' + currentUser.uid);
			} else {
				// Room typing
				typingRef = database.ref('typing/' + currentRoom + '/' + currentUser.uid);
			}
			
			// Set typing status
			typingRef.set(true);
			
			// Auto-remove after 3 seconds of inactivity
			clearTimeout(typingTimer);
			typingTimer = setTimeout(stopTyping, 3000);
			
			// Set up disconnect handler
			typingRef.onDisconnect().remove();
		} else {
			// Reset timer
			clearTimeout(typingTimer);
		}
	}

	// Clear all typing indicators when switching
	function clearAllTypingIndicators() {
		const chatButtons = document.querySelectorAll('.recent-chat-item');
		chatButtons.forEach(button => {
			// Remove typing class but keep online/offline status
			button.classList.remove('typing');
			
			// Get user ID from button
			const userId = button.dataset.userId;
			if (userId && allUsers[userId]) {
				const now = Date.now();
				const twoMinutesAgo = now - (2 * 60 * 1000);
				const isOnline = allUsers[userId].lastSeen && allUsers[userId].lastSeen > twoMinutesAgo;
				
				// Remove all status classes first
				button.classList.remove('online', 'offline');
				
				// Restore online/offline status
				if (isOnline) {
					button.classList.add('online');
				} else {
					button.classList.add('offline');
				}
			}
		});
	}

	// Stop typing indicator
	function stopTyping() {
		isTyping = false;
		
		let typingRef;
		
		if (privateChatUser) {
			// Private typing
			const chatId = [currentUser.uid, privateChatUser].sort().join('_');
			typingRef = database.ref('typing/' + chatId + '/' + currentUser.uid);
		} else {
			// Room typing
			typingRef = database.ref('typing/' + currentRoom + '/' + currentUser.uid);
		}
		
		// Remove typing status
		typingRef.remove();
		
		// Clear local indicator
		clearTimeout(typingTimer);
	}

	// Listen for typing indicators
	async function setupTypingListeners() {
		if (!typingIndicator) return; // Added: Null check
		
		// Clear existing typing indicator
		typingIndicator.textContent = '';
		
		let typingRef;
		
		if (privateChatUser) {
			// Private chat typing indicator
			const chatId = [currentUser.uid, privateChatUser].sort().join('_');
			typingRef = database.ref('typing/' + chatId);
		} else {
			// Room typing indicator
			typingRef = database.ref('typing/' + currentRoom);
		}
		
		typingRef.on('value', async (snapshot) => {
			if (!snapshot.exists()) {
				updateTypingIndicator([]);
				return;
			}

			const typingUserIds = Object.keys(snapshot.val() || {});
			const validTypingUserIds = typingUserIds.filter(uid => 
				uid !== currentUser.uid && !isUserBanned(uid)
			);

			if (validTypingUserIds.length === 0) {
				updateTypingIndicator([]);
				return;
			}

			// Fetch user data for all typing users at once
			const userPromises = validTypingUserIds.map(uid => 
				database.ref('users/' + uid).once('value').then(snap => snap.exists() ? snap.val() : null)
			);

			try {
				const users = await Promise.all(userPromises);
				const typingNames = users
					.filter(user => user !== null) // Filter out null results
					.map(user => user.displayName || 'Unknown User');

				updateTypingIndicator(typingNames);
			} catch (error) {
				console.error("Error fetching typing users:", error);
				updateTypingIndicator([]); // Clear indicator on error
			}
		});
		
		// NEW: Listen for typing status changes
		typingRef.on('child_added', async (snapshot) => {
			const userId = snapshot.key;
			const isTyping = snapshot.val();
			
			if (userId === currentUser.uid || isUserBanned(userId)) {
				return; // Ignore own typing and banned users
			}
			
			// Update chat button UI
			updateChatButtonTypingStatus(userId, isTyping);
		});
		
		// Listen for typing removal
		typingRef.on('child_removed', async (snapshot) => {
			const userId = snapshot.key;
			updateChatButtonTypingStatus(userId, false);
		});
	}

	// Update individual chat button typing status
	function updateChatButtonTypingStatus(userId, isTyping) {
		// Find the chat button for this user
		const chatButtons = document.querySelectorAll('.recent-chat-item');
		
		chatButtons.forEach(button => {
			if (button.dataset.userId === userId) {
				const user = allUsers[userId];
				if (!user) return;
				
				// Remove typing class
				button.classList.remove('typing');
				
				if (isTyping) {
					// Add typing class but keep online status
					button.classList.add('typing');
				} else {
					// Remove typing class and check online status
					const now = Date.now();
					const twoMinutesAgo = now - (2 * 60 * 1000);
					const isUserOnline = user.lastSeen && user.lastSeen > twoMinutesAgo;
					
					// Remove all status classes first
					button.classList.remove('online', 'offline');
					
					// Restore online/offline status
					if (isUserOnline) {
						button.classList.add('online');
					} else {
						button.classList.add('offline');
					}
				}
			}
		});
	}

	// Update typing indicator UI
	function updateTypingIndicator(users) {
		const typingIndicator = document.getElementById('typing-indicator');
		if (!typingIndicator) return;
		
		if (users.length === 0) {
			typingIndicator.textContent = '';
		} else if (users.length === 1) {
			typingIndicator.textContent = `${users[0]} is typing...`;
		} else {
			typingIndicator.textContent = `${users.join(', ')} are typing...`;
		}
	}

	// ====================================================================================================
	// VOICE MESSAGE FUNCTIONS
	// ====================================================================================================

	function startRecording() {
		if (isRecording) return;

		navigator.mediaDevices.getUserMedia({ audio: true })
			.then(stream => {
				isRecording = true;
				audioChunks = [];
				mediaRecorder = new MediaRecorder(stream);

				mediaRecorder.ondataavailable = event => {
					audioChunks.push(event.data);
				};

				mediaRecorder.onstop = () => {
					const audioBlob = new Blob(audioChunks, { type: 'audio/mp3' });
					uploadVoiceMessage(audioBlob);
				};

				mediaRecorder.start();
				recordVoiceBtn.textContent = '‚èπÔ∏è';
				recordVoiceBtn.classList.add('recording');
			})
			.catch(err => {
				console.error("Error accessing microphone:", err);
				notifications.error("Could not access your microphone. Please check permissions.", "Microphone Error");
			});
	}

	function stopRecording() {
		if (!isRecording || !mediaRecorder) return;

		mediaRecorder.stop();
		mediaRecorder.stream.getTracks().forEach(track => track.stop());
		isRecording = false;
		recordVoiceBtn.textContent = 'üé§';
		recordVoiceBtn.classList.remove('recording');
	}

	async function uploadVoiceMessage(audioBlob) {
		if (!storage) {
			notifications.error("Firebase Storage is not available.", "Upload Error");
			return;
		}

		isUploading = true;
		sendBtn.disabled = true;
		recordVoiceBtn.disabled = true;
		notifications.info("Uploading voice message...", "Uploading");

		const timestamp = Date.now();
		const fileName = `voiceMessages/${currentUser.uid}/${timestamp}.mp3`;
		const storageRef = storage.ref(fileName);

		try {
			const uploadTask = storageRef.put(audioBlob);
			await uploadTask;

			const downloadURL = await storageRef.getDownloadURL();
			sendVoiceMessage(downloadURL);
		} catch (error) {
			console.error("Error uploading voice message:", error);
			notifications.error("Failed to upload voice message.", "Upload Error");
		} finally {
			isUploading = false;
			sendBtn.disabled = false;
			recordVoiceBtn.disabled = false;
		}
	}

	function sendVoiceMessage(audioUrl) {
		if (!currentUser) return;

		const timestamp = Date.now();
		let messageRef;
		let messageData;

		const baseMessageData = {
			senderId: currentUser.uid,
			senderName: currentUser.displayName || 'User',
			timestamp: timestamp,
			isGuest: currentUser.isAnonymous,
			type: 'voice',
			content: audioUrl
		};

		if (privateChatUser) {
			const chatId = [currentUser.uid, privateChatUser].sort().join('_');
			messageRef = database.ref('privateMessages/' + chatId);
			messageData = baseMessageData;
		} else {
			messageRef = database.ref('messages/' + currentRoom);
			messageData = { ...baseMessageData, userId: currentUser.uid, username: currentUser.displayName || 'User' };
		}

		messageRef.push(messageData)
			.then(() => {
				console.log("Voice message sent successfully!");
				if (privateChatUser) {
					addToRecentChats(privateChatUser);
				}
			})
			.catch(error => {
				console.error("Error sending voice message:", error);
				notifications.error("Failed to send voice message.", "Send Error");
			});
	}

    // ====================================================================================================
    // EVENT LISTENERS
    // ====================================================================================================
    
    // Auth tab switching
    if (guestTab) guestTab.addEventListener('click', () => switchAuthTab('guest'));
    if (accountTab) accountTab.addEventListener('click', () => switchAuthTab('account'));
    if (showSignup) showSignup.addEventListener('click', (e) => {
        e.preventDefault();
        switchAuthPanel('signup');
    });
    if (showLogin) showLogin.addEventListener('click', (e) => {
        e.preventDefault();
        switchAuthPanel('login');
    });
    if (resetPasswordBtn) resetPasswordBtn.addEventListener('click', resetPassword);

    // Auth functionality
    if (guestLoginBtn) guestLoginBtn.addEventListener('click', loginAsGuest);
    if (loginBtn) loginBtn.addEventListener('click', loginWithEmail);
    if (signupBtn) signupBtn.addEventListener('click', signUp);
    if (setUsernameBtn) setUsernameBtn.addEventListener('click', setUsername);
    if (logoutBtn) logoutBtn.addEventListener('click', logout);
    
    // Allow Enter key to login from password field
    if (passwordInput) passwordInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            if (loginBtn) loginBtn.click();
        }
    });

    // Allow Enter key to sign up from password field
    if (displayName) displayName.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            if (signupBtn) signupBtn.click();
        }
    });

    // Allow Enter key to set username from username field
    if (chooseUsername) chooseUsername.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            if (setUsernameBtn) setUsernameBtn.click();
        }
    });
    
    // Allow Enter key to join as guest from the username field
    if (guestUsername) guestUsername.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            if (guestLoginBtn) guestLoginBtn.click();
        }
    });
    
    // Email verification button
    const verifyEmailBtn = document.getElementById('verify-email-btn');
    if (verifyEmailBtn) {
        verifyEmailBtn.addEventListener('click', sendEmailVerification);
    }
    
    // Room list
    if (roomList) roomList.addEventListener('click', (e) => {
        if (e.target.classList.contains('room-item')) {
            switchRoom(e.target.dataset.room);
        }
    });
    
    // New room modal
    if (openNewRoomModalBtn) openNewRoomModalBtn.addEventListener('click', () => {
        if (newRoomModal) newRoomModal.style.display = 'block';
        if (newRoomNameModal) newRoomNameModal.value = ''; // Clear input on open
        if (newRoomErrorMessage) newRoomErrorMessage.style.display = 'none'; // Hide error on open
    });

    if (closeNewRoomModalBtn) closeNewRoomModalBtn.addEventListener('click', () => {
        if (newRoomModal) newRoomModal.style.display = 'none';
    });

    // Handle Enter key in the modal input
    if (newRoomNameModal) newRoomNameModal.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            addRoomFromModal();
        }
    });

    // Recent chats functionality
    if (recentChatsList) recentChatsList.addEventListener('click', (e) => {
        const chatItem = e.target.closest('.recent-chat-item');
        if (chatItem) {
            startPrivateChat(chatItem.dataset.userId);
            // Close mobile sidebar after selecting chat
            if (window.innerWidth <= 480 && sidebar) {
                sidebar.classList.remove('open');
            }
        }
    });
	
	if (recordVoiceBtn) {
		recordVoiceBtn.addEventListener('click', () => {
			if (isRecording) {
				stopRecording();
			} else {
				startRecording();
			}
		});
	}
    
    if (startNewChatBtn) startNewChatBtn.addEventListener('click', () => {
        if (searchUserInput) searchUserInput.value = ''; // Clear previous search input
        populateAndShowSearchModal();
    });

    if (closeModalBtn) closeModalBtn.addEventListener('click', () => {
        if (newChatModal) newChatModal.style.display = 'none';
    });

    window.addEventListener('click', (e) => {
        if (e.target === newChatModal) {
            if (newChatModal) newChatModal.style.display = 'none';
        }
    });

    if (searchUserInput) searchUserInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        filterUsers(searchTerm);
    });

    // Mobile menu toggle
    if (mobileMenuToggle) mobileMenuToggle.addEventListener('click', () => {
        if (sidebar) sidebar.classList.toggle('open');
    });

    // Close sidebar when clicking outside on mobile
    document.addEventListener('click', (e) => {
        if (window.innerWidth <= 480 && 
            sidebar && !sidebar.contains(e.target) && 
            mobileMenuToggle && !mobileMenuToggle.contains(e.target) && 
            sidebar.classList.contains('open')) {
            sidebar.classList.remove('open');
        }
    });

    // Collapse toggle listeners
    document.querySelectorAll('.collapse-toggle').forEach(toggle => {
        toggle.addEventListener('click', (e) => {
            e.stopPropagation();
            const sectionId = toggle.dataset.section;
            toggleSection(sectionId);
        });
    });

    // Section header click to toggle
    document.querySelectorAll('.section-header').forEach(header => {
        header.addEventListener('click', (e) => {
            // Don't toggle if clicking on buttons
            if (e.target.classList.contains('refresh-btn') || 
                e.target.classList.contains('collapse-toggle')) {
                return;
            }
            const section = header.closest('.collapsible-section');
            if (section) {
                toggleSection(section.id);
            }
        });
    });

    // Admin tab switching
    document.querySelectorAll('.admin-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            // Check if this is a leader-only tab and user is not leader
            if ((btn.dataset.tab === 'chats' || btn.dataset.tab === 'database') && !isCurrentUserLeader()) {
                notifications.error('only leaders can access this tab, bro.', 'Access Denied', '6000');
                return;
            }
            
            switchAdminTab(btn.dataset.tab);
        });
    });

    // Admin functionality
    if (banUserBtn) {
        banUserBtn.addEventListener('click', () => {
            const userId = adminUserSelect.value;
            const reason = adminReasonInput.value.trim();
            banUser(userId, reason);
        });
    }
    
    if (unbanUserBtn) {
        unbanUserBtn.addEventListener('click', () => {
            const userId = adminUserSelect.value;
            unbanUser(userId);
        });
    }
    
    if (grantAdminBtn) {
        grantAdminBtn.addEventListener('click', () => {
            const userId = adminUserSelect.value;
            grantAdmin(userId);
        });
    }
    
    if (revokeAdminBtn) {
        revokeAdminBtn.addEventListener('click', () => {
            const userId = adminUserSelect.value;
            revokeAdmin(userId);
        });
    }

    // Admin user select change
    if (adminUserSelect) {
        adminUserSelect.addEventListener('change', () => {
            showUserDetails(adminUserSelect.value);
        });
    }
    
    const refreshAdminUsersBtn = document.getElementById('refresh-admin-users-btn');
    if (refreshAdminUsersBtn) {
        refreshAdminUsersBtn.addEventListener('click', async () => {
            try {
                refreshAdminUsersBtn.disabled = true;
                refreshAdminUsersBtn.textContent = '...';
                await loadUsers();
                updateAdminUserSelect();
                loadContactsList();
                notifications.success("Users list refreshed", 'Success', 3000);
            } catch (error) {
                notifications.error("Failed to refresh users list", 'Error', 5000);
            } finally {
                refreshAdminUsersBtn.disabled = false;
                refreshAdminUsersBtn.textContent = '‚Üª';
            }
        });
    }
    
    const refreshBannedBtn = document.getElementById('refresh-banned-btn');
    if (refreshBannedBtn) {
        refreshBannedBtn.addEventListener('click', refreshBannedUsers);
    }

    // Typing indicator
    if (messageInput) messageInput.addEventListener('input', handleTyping);
    
    // Message functionality
    if (sendBtn) sendBtn.addEventListener('click', sendMessage);
    if (messageInput) messageInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });

    // Initialize collapsed sections
    initCollapsedSections();
    applyCollapsedStates();
    
    // Setup image upload
    setupImageUpload();
    
    // Listen for auth state changes
    auth.onAuthStateChanged(user => {
        console.log("üîê Auth state changed!");
        console.log("üîê User object:", user);

        if (user) {
            // User is signed in.
            console.log("üîê User is signed in. Setting up user...");
            currentUser = user;
            setupUser();
        } else {
            // User is signed out.
            console.log("üîê User is signed out. Showing login screen.");
            currentUser = null;
            isInitialized = false; // Reset initialization flag
            logout(); // Use your logout function to reset the UI
        }
    });
    
    // Test if function exists
    console.log('üîß showSettingsPanel function:', typeof showSettingsPanel);

    // Test if panel element exists
    console.log('üîß Settings panel element:', document.getElementById('settings-panel'));
    
    // ====================================================================================================
    // SOUND EFFECTS
    // ====================================================================================================
    
    function playNotificationSound() {
        const audio = document.getElementById('notification-sound');
        if (audio) {
            // Set volume to a reasonable level (e.g., 30%)
            audio.volume = 0.3; 
            
            // Play the sound
            audio.play().catch(error => {
                console.error("Error playing notification sound:", error);
                // Autoplay might be blocked by browser, this is a common issue
            });
        }
    }
    
    // ====================================================================================================
    // DEBUGGING
    // ====================================================================================================
    
    // Test ban notification
    function testBanNotification() {
        console.log("Testing ban notification...");
        showBannedNotification("Test ban reason - this is just a test");
    }

    // Test unban notification
    function testUnbanNotification() {
        console.log("Testing unban notification...");
        hideBannedNotification();
    }
});        here is the style.css: /* ==================== CSS CUSTOM PROPERTIES (VARIABLES) ==================== */
:root {
    --primary-color: #bb86fc;
    --primary-hover: #a370fc;
    --background-primary: #121212;
    --background-secondary: #1e1e1e;
    --background-tertiary: #2a2a2a;
    --surface-color: #2e2e2e;
    --text-primary: #e0e0e0;
    --text-secondary: #9e9e9e;
    --text-disabled: #555;
    --border-color: #333;
    --error-color: #cf6679;
    --success-color: #4caf50;
    --warning-color: #ff9800;
    --leader-color: #ffd700;
    --scrollbar-thumb: #555;
    --scrollbar-thumb-hover: #777;
    --scrollbar-track: var(--background-secondary);
}

/* ==================== GLOBAL STYLES & OVERRIDES ==================== */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    background: linear-gradient(135deg, #1a1a2e, #32264a);
    color: var(--text-primary);
    font-family: 'Consolas', 'Aptos Mono', 'Monaco', 'Cascadia Code', monospace;
    height: 100vh;
    overflow: hidden;
}

/* Prevent browser defaults from interfering */
input, button, select, textarea {
    font-family: inherit;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background: transparent;
    border: none;
    outline: none;
}

/* ==================== AUTHENTICATION STYLES ==================== */
.auth-container {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    background: linear-gradient(180deg, #203036, #262657);
}

.auth-form {
    background: linear-gradient(300deg, rgb(46, 46, 46), rgb(30, 30, 30));
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    width: 100%;
    max-width: 400px;
}

.auth-panel {
    display: none;
    flex-direction: column;
    gap: 15px;
}

.auth-panel.active {
    display: flex;
}

.auth-panel h2 {
    text-align: center;
    font-size: 20px;
    font-weight: 300;
    letter-spacing: 2px;
    color: var(--primary-color);
	cursor: default;
}

.auth-panel input {
    padding: 12px 15px;
    border: 1px solid var(--border-color);
    border-radius: 30px;
    font-size: 16px;
    background-color: var(--background-tertiary);
    color: var(--text-primary);
    transition: border-color 0.3s;
}

.auth-panel input:focus {
    border-color: var(--primary-color);
}

.auth-switch {
    text-align: center;
    font-size: 14px;
    color: var(--text-secondary);
	cursor: default;
}

.auth-switch a {
    color: var(--primary-color);
    text-decoration: none;
    font-weight: 500;
    transition: color 0.3s;
	cursor: pointer;
}

.auth-switch a:hover {
    color: var(--primary-hover);
}

.auth-tab {
    flex: 1;
    padding: 10px;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 16px;
    color: var(--text-secondary);
    transition: all 0.3s;
}

.auth-tab.active {
    color: var(--primary-color);
    border-bottom: 2px solid var(--primary-color);
}

.auth-tabs {
    display: flex;
    margin-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
}

.app-logo {
    text-align: center;
    margin-bottom: 30px;
	cursor: default;
}

.app-logo h1 {
    font-size: 32px;
    font-weight: 500;
    letter-spacing: 2px;
    color: var(--primary-color);
    margin-bottom: 5px;
	cursor: default;
}

.app-logo p {
    color: var(--text-secondary);
    font-size: 14px;
	cursor: default;
}

.disabled-overlay {
    background-color: rgba(0, 0, 0, 0.7);
    color: var(--text-primary);
    padding: 20px;
    border-radius: 15px;
    text-align: center;
    margin-bottom: 15px;
    border: 1px solid var(--error-color);
	cursor: default;
}

.disabled-overlay h3 {
    color: var(--error-color);
    margin-bottom: 5px;
	cursor: pointer;
}

/* ==================== GUEST LOGIN DISABLED STYLES ==================== */
#guest-tab {
    color: var(--text-disabled);
    cursor: not-allowed;
    opacity: 0.5;
}

#guest-panel {
    position: relative;
    pointer-events: none; /* Prevents any interaction */
}

#guest-panel .input-with-button {
    opacity: 0.4;
    filter: blur(1px); /* The missing blur effect */
}

#guest-panel p {
    text-align: center;
    font-size: 14px;
    font-weight: 250;
    letter-spacing: 0.75px;
    color: var(--text-secondary);
    margin-bottom: 3px;
	cursor: default;
}

/* ==================== MAIN APP LAYOUT ==================== */
.app-container {
    height: 100vh;
    display: flex;
}

.app-main {
    flex: 1;
    display: flex;
    height: 100vh;
    position: relative;
}

/* ==================== SIDEBAR STYLES ==================== */
.sidebar {
    width: 280px;
    height: 100%;
    background-color: var(--background-secondary);
    color: var(--text-primary);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    border-right: 1px solid var(--border-color);
    flex-shrink: 0;
    transform: translateX(0);
    transition: transform 0.3s ease;
}

.sidebar-footer {
    margin-top: auto;
    padding: 20px;
    text-align: center;
    font-size: 12px;
    color: var(--text-secondary);
    border-top: 1px solid var(--border-color);
    flex-shrink: 0;
}

.sidebar-footer a {
    color: var(--primary-color);
    text-decoration: none;
    font-weight: 500;
    transition: color 0.3s;
}

.sidebar-footer a:hover {
    color: var(--primary-hover);
}

/* Typing indicator for chat buttons */
.recent-chat-item {
    position: relative;
    transition: all 0.3s ease;
}

.recent-chat-item.typing {
    border-right: 3px solid #fff;
    transition: all 0.3s ease;
	background-color: linear-gradient(180deg, #2e2e2e, #1e1e1e);
}



/* ==================== CHAT AREA STYLES ==================== */
.chat-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    background-color: var(--background-primary);
    min-height: 0;
}

.chat-header {
    flex-shrink: 0;
    padding: 20px;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--background-secondary);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.chat-header h2 {
    color: var(--text-primary);
    margin-bottom: 5px;
}

.app-branding {
	font-weight: 1000;
	font-size: 36px;
	color: #bb86fc;
}

.header-left {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    min-width: 0;
}

#current-room-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.messages {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 15px;
    background: linear-gradient(300deg, #20192b, var(--background-secondary));
}

/* ==================== MESSAGE INPUT & CONTROLS ==================== */
.message-input {
    flex-shrink: 0;
    display: none;
    padding: 15px;
    border-top: 1px solid var(--border-color);
    background-color: var(--background-secondary);
    flex-direction: column;
    gap: 10px;
}

.message-input-typing {
    position: absolute;
    top: -25px;
    left: 15px;
    color: var(--text-secondary);
    font-size: 12px;
    font-style: italic;
    height: 20px;
    transition: all 0.3s ease;
}

.app-container.user-logged-in .message-input {
    display: flex;
}

.message-input .input-with-button {
    display: flex;
    align-items: center;
    background-color: var(--background-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 30px;
    padding: 2px;
    transition: border-color 0.3s;
}

.message-input .input-with-button:focus-within {
    border-color: var(--primary-color);
}

.message-input input {
    flex: 1;
    padding: 12px 15px;
    font-size: 16px;
    color: var(--text-primary);
}

.message-input button {
    background-color: var(--primary-color);
    color: var(--background-primary);
    border-radius: 30px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.3s;
    padding: 8px 17px;
    margin-right: 8px;
}

.message-input button:hover {
    background-color: var(--primary-hover);
}

/* Image Preview */
.image-preview {
    position: absolute;
    bottom: 100%;
    left: 0;
    right: 0;
    background: var(--background-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px 8px 0 0;
    padding: 10px;
    box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.3);
    z-index: 1000;
}

.preview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}

.preview-header span {
    color: var(--primary-color);
    font-weight: 500;
    font-size: 14px;
}

.cancel-btn {
    background: none;
    color: var(--text-secondary);
    font-size: 18px;
    cursor: pointer;
    padding: 2px;
    border-radius: 50%;
    transition: all 0.2s;
}

.cancel-btn:hover {
    color: var(--error-color);
    background-color: rgba(207, 102, 121, 0.1);
}

.preview-image {
    max-width: 100%;
    max-height: 200px;
    border-radius: 4px;
    object-fit: contain;
    background: var(--background-tertiary);
}

.preview-info {
    display: flex;
    justify-content: space-between;
    margin-top: 8px;
    font-size: 12px;
    color: var(--text-secondary);
}

/* --- Voice Message Button & Player --- */

#record-voice-btn {
    background: none;
    border: none;
    font-size: 1.5em;
    cursor: pointer;
    padding: 0 10px;
    transition: transform 0.2s ease, color 0.2s ease;
}

#record-voice-btn:hover {
    transform: scale(1.1);
}

#record-voice-btn.recording {
    color: #e74c3c;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

.voice-player {
    width: 100%;
    height: 36px;
    margin-top: 5px;
}

/* ==================== MESSAGE STYLES ==================== */
.message {
    padding: 12px 15px;
    border-radius: 20px;
    background-color: var(--background-tertiary);
    max-width: 40%;
    word-wrap: break-word;
    position: relative;
}

.message.current-user {
    background-color: #8757c2;
    color: var(--background-primary);
    align-self: flex-end;
}

.message.current-user .username {
    color: rgba(255, 255, 255, 0.7);
    font-weight: bold;
}

.message.current-user .time {
    color: #9e9e9e;
}

.message[data-guest="true"] .username {
    color: var(--text-secondary);
    font-style: italic;
}

.message[data-guest="true"] {
    border-left: 3px solid #757575;
}

.message.is-reply {
    border-left: 5px solid #8757c2;
}

.admin-message {
    border-left: 3px solid var(--primary-color);
    background-color: rgba(187, 134, 252, 0.1);
    box-shadow: 0 0 8px rgba(187, 134, 252, 0.15);
}

.message.leader-message {
    border: 2px solid var(--leader-color);
    background-color: rgba(255, 215, 0, 0.1);
    box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
    border-radius: 20px;
}

.message.leader-message .username {
    color: var(--leader-color);
    font-weight: bold;
}

.message.admin-message .username {
    color: var(--primary-color);
    font-weight: bold;
}

.message:hover .reply-button-container {
    opacity: 1;
    pointer-events: auto;
}

.replied-to-message {
    font-size: 12px;
    color: var(--text-primary);
    margin-bottom: 5px;
    padding: 5px;
    background-color: rgba(154, 82, 242, 0.1);
    border-radius: 10px;
    border: 1px solid #fff;
}

.reply-button-container {
    position: absolute;
    top: 5px;
    right: 10px;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    pointer-events: none;
}

.reply-button {
    background: none;
    border: 1px solid #555;
    color: var(--text-secondary);
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.2s;
}

.reply-button:hover {
    background-color: #333;
    color: var(--text-primary);
    border-color: var(--primary-color);
}

.reply-preview {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: var(--background-tertiary);
    padding: 8px 12px;
    border-radius: 20px;
    color: var(--primary-color);
    font-size: 12px;
    margin-bottom: 5px;
}

.cancel-reply-btn {
    background: none;
    border: none;
    color: var(--text-secondary);
    font-size: 16px;
    cursor: pointer;
    padding: 0;
    margin-left: 10px;
}

.cancel-reply-btn:hover {
    color: var(--text-primary);
}

.username {
    font-weight: 600;
    margin-bottom: 5px;
    color: var(--primary-color);
    font-size: 14px;
}

.text {
    line-height: 1.4;
    color: var(--text-primary);
    overflow-wrap: break-word;
    word-break: break-word;
}

.time {
    font-size: 11px;
    color: var(--text-secondary);
    margin-top: 5px;
    text-align: right;
}

/* ==================== USER PROFILE STYLES ==================== */
.user-profile {
    padding: 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

.user-avatar {
    width: 51px;
    height: 51px;
    border-radius: 50%;
    background-color: var(--primary-color);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 20px;
    font-weight: bold;
    color: var(--background-primary);
    flex-shrink: 0;
}

.user-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
}

.user-name-container {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 8px;
}

.user-name {
    font-size: 16px;
    font-weight: 500;
}

/* Email Verification Icon */
.email-verification-icon {
    position: relative;
    cursor: pointer;
}

.verification-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    font-size: 11px;
    font-weight: bold;
    color: white;
    transition: transform 0.2s ease;
}

.email-verification-icon:hover .verification-icon {
    transform: scale(1.1);
}

.verification-icon.verified { background-color: var(--success-color); }
.verification-icon.not-verified { background-color: var(--error-color); }

/* Tooltip */
.verification-tooltip {
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-top: 8px;
    background: var(--background-tertiary);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 12px;
    min-width: 200px;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.email-verification-icon:hover .verification-tooltip {
    opacity: 1;
    visibility: visible;
}

.tooltip-content { color: #fff; text-align: center; }
#tooltip-status { display: block; font-weight: 500; margin-bottom: 6px; font-size: 13px; }
.tooltip-email { font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; word-break: break-all; }
.tooltip-btn { width: 100%; padding: 6px 10px; background-color: var(--error-color); border-radius: 4px; color: white; font-size: 11px; cursor: pointer; transition: background-color 0.2s ease; }
.tooltip-btn:hover { background-color: #d32f2f; }
.tooltip-btn:disabled { opacity: 0.6; cursor: not-allowed; }

/* Auth Actions */
.auth-actions { display: flex; align-items: center; gap: 10px; }
.logout-btn {
    background: linear-gradient(135deg, #c0392b, #f52611, #c0392b);
    color: white;
    padding: 4px 6px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 12px;
    flex: 1;
}
.logout-btn:hover { background: #c0392b; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);}
.logout-btn:active { transform: translateY(0); }

/* ==================== COLLAPSIBLE SECTIONS ==================== */
.collapsible-section { border-bottom: 1px solid var(--border-color); }
.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.3s;
}
.section-header:hover { background-color: var(--background-tertiary); }
.section-header h3 { color: var(--primary-color); font-size: 16px; margin: 0; }
.section-controls { display: flex; gap: 8px; align-items: center; }
.collapse-toggle {
    background: none;
    border: none;
    color: var(--primary-color);
    font-size: 14px;
    cursor: pointer;
    transition: transform 0.3s, color 0.3s;
    padding: 2px 6px;
    border-radius: 5px;
}
.collapse-toggle:hover { background-color: rgba(187, 134, 252, 0.1); color: var(--primary-hover); }
.collapse-toggle.collapsed { transform: rotate(-90deg); }
.section-content {
    overflow: hidden;
    transition: max-height 0.3s ease, opacity 0.3s ease;
    max-height: 500px;
    opacity: 1;
}
.section-content.collapsed { max-height: 0; opacity: 0; }

/* ==================== RECENT CHATS & ROOMS SECTIONS ==================== */
.recent-chats-list, .room-list {
    padding: 0 20px 15px;
    display: flex;
    flex-direction: column;
    gap: 5px;
    max-height: 200px;
    overflow-y: auto;
}

.recent-chat-item, .room-item {
    padding: 10px;
    border-radius: 15px;
    cursor: pointer;
    transition: background-color 0.3s;
}
.recent-chat-item:hover, .room-item:hover { background-color: var(--background-tertiary); }
.room-item.active { background-color: var(--primary-color); color: var(--background-primary); }
.recent-chat-item.active { background-color: var(--primary-color); color: var(--background-primary); }

.chat-info { display: flex; flex-direction: column; flex: 1; }
.chat-name { font-weight: 500; color: white; display: flex; align-items: center; gap: 5px; }
.chat-preview { font-size: 12px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; }
.chat-status { display: flex; flex-direction: column; align-items: flex-end; }
.chat-time { font-size: 10px; color: var(--text-secondary); }

#status-indicator {
	align-self: right;
	align-content: right;
	align-items: right;
}

.recent-chat-item.active {
	border: 2px solid #bb86fc;
	transition: all 0.3s ease;
}

.recent-chat-item:hover {
	border: 1px solid #2e2e2e;
	transition: all 0.3s ease;
}

.recent-chat-item.online {
    background: linear-gradient(to right, 
        rgba(76, 175, 80, 0.25) 0%, 
        var(--background-tertiary) 100%);
	transition: all 0.3s ease;
}

.recent-chat-item.offline {
    background-color: var(--background-tertiary);
	transition: all 0.3s ease;
}

.recent-chat-item.typing {
    background: linear-gradient(to right, 
        rgba(76, 175, 80, 0.25) 0%,
		rgba(255, 255, 255, 0.25) 100%); 
    border-right: 3px solid #fff;
	transition: all 0.3s ease;
}

.recent-chat-item.admin:not(.online):not(.typing) {
    background: var(--background-tertiary);
	transition: all 0.3s ease;
}

.recent-chat-item.leader:not(.online):not(.typing) {
	background: var(--background-tertiary);
	transition: all 0.3s ease;
}

.recent-chat-item.admin.online {
    background: linear-gradient(to right, 
        rgba(84, 102, 235, 0.5) 0%,
		var(--background-tertiary) 100%);
	transition: all 0.3s ease;
}

.recent-chat-item.leader.online {
    background: linear-gradient(to right, 
        rgba(255, 215, 0, 0.5) 0%,
		var(--background-tertiary) 100%);
	transition: all 0.3s ease;
}

.recent-chat-item.admin.typing {
    background: linear-gradient(to right, 
		rgba(84, 102, 235, 0.25) 0%,
		rgba(255, 255, 255, 0.25) 100%);
	border-right: 3px solid #fff;
	transition: all 0.3s ease;
}

.recent-chat-item.leader.typing {
    background: linear-gradient(to right, 
		rgba(255, 215, 0, 0.25) 0%
		rgba(255, 255, 255, 0.5) 100%);
	border-right: 3px solid #fff;
	transition: all 0.3s ease;
}

.recent-chat-item.admin .chat-name {
    font-weight: 600;
    color: rgba(139, 151, 240, 1);
	transition: all 0.3s ease;
}

.recent-chat-item.leader .chat-name {
    font-weight: 600;
    color: var(--leader-color);
	transition: all 0.3s ease;
}

.refresh-btn {
    background: none;
    border: 1px solid var(--primary-color);
    color: var(--primary-color);
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: all 0.3s;
    font-size: 14px;
}
.refresh-btn:hover { background-color: var(--primary-color); color: var(--background-primary); }

/* ==================== ADMIN COMPONENTS ==================== */
.admin-controls { padding: 8px 15px 15px 15px; display: flex; flex-direction: column; gap: 15px; }
.admin-form-group { display: flex; flex-direction: column; gap: 5px; }
.admin-form-group label { color: var(--text-primary); font-size: 14px; }
.admin-textarea {
    padding: 10px 15px;
    border: 1px solid var(--border-color);
    border-radius: 15px;
    font-size: 14px;
    background-color: var(--background-tertiary);
    color: var(--text-primary);
    resize: vertical;
    min-height: 80px;
}

.admin-user-select-wrapper { position: relative; width: 100%; margin-bottom: 15px; }
.admin-select-container { position: relative; width: 100%; }
#admin-user-select {
    width: 100%;
    padding: 10px 30px 10px 15px;
    border: 1px solid var(--border-color);
    border-radius: 15px;
    font-size: 14px;
    background-color: var(--background-tertiary);
    color: var(--text-primary);
    cursor: pointer;
}
#admin-user-select:focus { border-color: var(--primary-color); }
#refresh-admin-users-btn {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    padding: 5px;
    border-radius: 50%;
    transition: background-color 0.2s;
    z-index: 10;
}
#refresh-admin-users-btn:hover { background-color: rgba(255, 255, 255, 0.1); }

.admin-user-info {
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    padding: 10px;
    margin-bottom: 10px;
    font-size: 12px;
}
.user-info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 5px; }
.info-item { display: flex; flex-direction: column; font-size: 11px; }
.info-label { font-size: 10px; color: var(--text-secondary); margin-bottom: 2px; }

.admin-buttons, .leader-buttons { display: flex; flex-wrap: wrap; gap: 5px; }
.admin-button {
    padding: 8px 15px;
    border-radius: 15px;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.2s;
    color: white;
}
.ban-button { background-color: var(--error-color); }
.unban-button { background-color: var(--success-color); }
.grant-button { background-color: #2196F3; }
.revoke-button { background-color: var(--warning-color); }

.admin-notification {
    padding: 10px;
    border-radius: 10px;
    margin-top: 10px;
    font-size: 14px;
}
.admin-notification.success { background-color: rgba(76, 175, 80, 0.2); color: var(--success-color); border: 1px solid var(--success-color); }
.admin-notification.error { background-color: rgba(244, 67, 54, 0.2); color: var(--error-color); border: 1px solid var(--error-color); }

/* Role-based visibility */
.leader-only, .admin-only { display: none; }
body.is-leader .leader-only { display: inline-block; }
body.is-admin .admin-only { display: inline-block; }

/* Leader contacts styling */
.leader-contact {
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 215, 0, 0.05));
    padding-left: 12px;
    margin-left: -3px;
}

.leader-contact .chat-name {
    font-weight: 600;
    color: gold;
}

/* Dark theme support */
body.theme-dark .leader-contact {
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 215, 0, 0.08));
}

body.theme-dark .leader-contact .chat-name {
    color: #ffd700;
    text-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
}

/* ==================== MODAL STYLES ==================== */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
}
.modal-content {
    background-color: var(--background-secondary);
    margin: 15% auto;
    padding: 20px;
    border-radius: 15px;
    width: 80%;
    max-width: 400px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}
.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}
.modal-header h3 { color: var(--primary-color); }
.close-modal {
    background: none;
    border: none;
    color: var(--text-secondary);
    font-size: 24px;
    cursor: pointer;
}
.close-modal:hover { color: var(--text-primary); }
.search-user-input {
    width: 100%;
    padding: 12px 15px;
    border: 1px solid var(--border-color);
    border-radius: 15px;
    font-size: 14px;
    background-color: var(--background-tertiary);
    color: var(--text-primary);
    margin-bottom: 15px;
}
.search-user-input:focus { border-color: var(--primary-color); }
.search-results { max-height: 200px; overflow-y: auto; }
.search-result-item {
    padding: 10px;
    border-radius: 15px;
    cursor: pointer;
    transition: background-color 0.3s;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.search-result-item:hover { background-color: var(--background-tertiary); }
.search-result-name { font-weight: 500; }
.search-result-status { font-size: 12px; color: var(--text-secondary); }
.error-message {
    color: var(--error-color);
    font-size: 12px;
    text-align: center;
    margin-top: 10px;
    padding: 8px;
    border-radius: 4px;
    background-color: rgba(207, 102, 121, 0.1);
    border: 1px solid rgba(207, 102, 121, 0.3);
}
.modal-footer { display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px; }
.btn { padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease; }
.btn-secondary { background-color: #616161; color: white; }
.btn-danger { background-color: var(--error-color); color: white; }
.btn:hover { opacity: 0.9; }

/* ==================== PUSH NOTIFICATION SYSTEM STYLING ==================== */
.push-notification-control {
    padding: 15px;
    border-bottom: 1px solid var(--border-color);
    text-align: center;
}

.push-toggle-btn {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 25px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.3s;
    margin-bottom: 10px;
}

.push-toggle-btn:hover {
    background-color: var(--primary-hover);
    transform: translateY(-2px);
}

.push-toggle-btn.subscribed {
    background-color: var(--success-color);
}

.push-status-text {
    color: var(--text-secondary);
    font-size: 12px;
    display: block;
    margin-top: 5px;
}

/* Mobile adjustments */
@media (max-width: 480px) {
    .push-notification-control {
        padding: 10px;
    }
    
    .push-toggle-btn {
        padding: 8px 16px;
        font-size: 12px;
    }
}

/* ==================== IN-APP NOTIFICATION SYSTEM STYLING ==================== */
/* Notification Container - CRITICAL: Remove pointer-events: none */
.notification-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 10000;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

/* Base Notification Styles */
.notification {
    background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 16px 20px;
    min-width: 300px;
    max-width: 400px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    display: flex;
    align-items: center;
    gap: 12px;
    
    /* --- Animation Properties --- */
    opacity: 0 !important;
    transform: translateX(100%) !important;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
    pointer-events: auto;
    cursor: pointer;
}

/* --- Animation State --- */
.notification.show {
    opacity: 1 !important;
    transform: translateX(0) !important;
}

/* --- Notification Icon --- */
.notification-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    flex-shrink: 0;
    font-size: 14px;
    font-weight: bold;
    color: white;
}

/* --- Notification Content --- */
.notification-content {
    flex: 1;
}

.notification-title {
    font-weight: 600;
    margin-bottom: 4px;
    color: #fff;
    font-size: 14px;
}

.notification-message {
    color: #e0e0e0;
    font-size: 13px;
    line-height: 1.4;
}

/* --- Close Button --- */
.notification-close {
    background: none;
    border: none;
    color: #9e9e9e;
    font-size: 18px;
    cursor: pointer;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.notification-close:hover {
    background-color: rgba(255, 255, 255, 0.1);
    color: #fff;
}


/* ==================== NOTIFICATION TYPE STYLES ==================== */

/* --- Success --- */
.notification.success {
    border-left: 4px solid #4caf50;
}

.notification.success .notification-icon {
    background-color: #4caf50 !important;
}

.notification.success .notification-icon::before {
    content: "‚úì" !important;
}

/* --- Error --- */
.notification.error {
    border-left: 4px solid #f44336;
}

.notification.error .notification-icon {
    background-color: #f44336 !important;
}

.notification.error .notification-icon::before {
    content: "‚úï" !important;
}

/* --- Warning --- */
.notification.warning {
    border-left: 4px solid #ff9800;
}

.notification.warning .notification-icon {
    background-color: #ff9800 !important;
}

.notification.warning .notification-icon::before {
    content: "!" !important;
}

/* --- Info --- */
.notification.info {
    border-left: 4px solid #2196f3;
}

.notification.info .notification-icon {
    background-color: #2196f3 !important;
}

.notification.info .notification-icon::before {
    content: "i" !important;
}

/* ==================== BANNED USER STYLES ==================== */
.banned-notification {
    display: none;
    z-index: 1000;
    position: relative;
    color: white;
    padding: 15px;
    margin: 10px;
    border-radius: 15px;
    box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
    
    background-image: linear-gradient(45deg, #c0392b, #f52611, #c0392b);
    
    background-size: 400% 400%;
}

#banned-notification.show {
    display: flex !important;
}

.banned-notification.animated-bg {
    animation: rotate-gradient 8s ease infinite;
}

@keyframes rotate-gradient {
    0% {
        background-position: 0% 50%;
    }
    50% {
        background-position: 100% 50%;
    }
    100% {
        background-position: 0% 50%;
    }
}

.banned-content {
    display: flex;
    align-items: center;
    gap: 15px;
    width: 100%;
}

.banned-icon {
    font-size: 24px;
    flex-shrink: 0;
}

.banned-message h3 {
    margin: 0 0 10px 0;
    font-size: 16px;
}

.banned-message p {
    margin: 5px 0;
    font-size: 14px;
    opacity: 0.9;
}

#ban-reason-text {
    font-weight: bold;
}

.banned-state {
    filter: blur(4px);
    opacity: 0.6;
    pointer-events: none;
    user-select: none;
    transition: filter 0.3s ease, opacity 0.3s ease;
}

/* ==================== CALLING STYLES (MIGRATED FROM AA-ECHO) ==================== */

/* The main modal for the call interface */
#call-modal {
    display: none; /* Controlled by JS */
    position: fixed;
    z-index: 1001; /* Higher than other modals */
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(5px);
}

.call-modal-content {
    background-color: var(--background-secondary);
    margin: 0 auto; /* Centered differently */
    padding: 0;
    border-radius: 15px;
    width: 100%;
    max-width: 900px;
    height: 90vh;
    max-height: 700px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    border: 1px solid var(--border-color);
    position: relative;
    top: 50%;
    transform: translateY(-50%);
}

/* Video Container */
.video-container {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: var(--background-primary);
    border-radius: 15px 15px 0 0;
    position: relative;
    overflow: hidden;
}

/* Video Elements */
.video-element {
    width: 100%;
    height: 100%;
    object-fit: cover;
    background-color: #000;
}

#remote-video {
    z-index: 1;
}

#local-video {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 200px;
    height: 150px;
    border: 2px solid var(--primary-color);
    border-radius: 15px;
    z-index: 2;
    background-color: #333;
    transform: scaleX(-1); /* Mirror local video */
}

/* Call Header */
.call-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    background-color: var(--background-tertiary);
    border-bottom: 1px solid var(--border-color);
    border-radius: 15px 15px 0 0;
}

.call-user-info h3 {
    color: var(--text-primary);
    font-size: 18px;
    margin: 0;
}

.call-user-info p {
    color: var(--text-secondary);
    font-size: 14px;
    margin: 0;
}

/* Call Controls */
.call-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    gap: 20px;
    background-color: var(--background-tertiary);
    border-radius: 0 0 15px 15px;
}

.call-btn {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 28px;
    color: var(--text-primary);
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: all 0.2s ease, transform 0.2s ease;
}

.call-btn:hover {
    transform: scale(1.1);
}

.call-btn.mic-active { color: var(--text-primary); }
.call-btn.mic-muted { color: var(--error-color); background-color: rgba(207, 102, 121, 0.1); }
.call-btn.video-active { color: var(--text-primary); }
.call-btn.video-disabled { color: var(--error-color); background-color: rgba(207, 102, 121, 0.1); }
.call-btn.end-call {
    background-color: var(--error-color);
    color: white;
}
.call-btn.end-call:hover {
    background-color: #d32f2f;
}

/* Incoming Call Screen */
.incoming-call-container {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100%;
    text-align: center;
    padding: 40px;
}

.incoming-call-container .user-avatar {
    width: 120px;
    height: 120px;
    font-size: 48px;
    margin-bottom: 20px;
    border: 3px solid var(--primary-color);
}

.incoming-call-container h2 {
    color: var(--text-primary);
    font-size: 28px;
    margin-bottom: 10px;
}

.incoming-call-container p {
    color: var(--text-secondary);
    font-size: 18px;
    margin-bottom: 40px;
}

.incoming-call-controls {
    display: flex;
    gap: 30px;
}

.incoming-call-controls .call-btn {
    width: 80px;
    height: 80px;
    font-size: 36px;
}

.incoming-call-controls .call-btn.accept {
    background-color: var(--success-color);
    color: white;
}
.incoming-call-controls .call-btn.accept:hover {
    background-color: #388e3c;
}

/* Call Button in Sidebar */
.sidebar-call-btn {
    background: none;
    border: none;
    color: var(--text-secondary);
    font-size: 16px;
    cursor: pointer;
    padding: 5px;
    border-radius: 50%;
    transition: all 0.2s ease;
    margin-left: auto; /* Pushes it to the right */
}

.sidebar-call-btn:hover {
    color: var(--primary-color);
    background-color: rgba(187, 134, 252, 0.1);
    transform: scale(1.1);
}

/* ==================== SPECIAL COMPONENTS ==================== */
/* Input with Button Inside */
.input-with-button {
    display: flex;
    align-items: center;
    background-color: var(--background-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 30px;
    padding: 2px;
    transition: border-color 0.3s;
}
.input-with-button:focus-within { border-color: var(--primary-color); }
.input-with-button input { flex: 1; }
.input-with-button button {
    background-color: var(--primary-color);
    color: var(--background-primary);
    border-radius: 30px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.3s;
    padding: 8px 17px;
    margin-right: 8px;
}
.input-with-button button:hover { background-color: var(--primary-hover); }

/* Loading Spinner */
.spinner {
    display: inline-block;
    width: 14px;
    height: 14px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #fff;
    animation: spin 1s ease-in-out infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.button-loading { cursor: not-allowed; opacity: 0.7; }

/* In-Message Loader */
.messages-loading-container {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100%;
    color: var(--text-secondary);
}
.loading-spinner-large {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(187, 134, 252, 0.3);
    border-radius: 50%;
    border-top-color: var(--primary-color);
    animation: spin 1s ease-in-out infinite;
    margin-bottom: 15px;
}

/* ==================== SCROLLBAR STYLING ==================== */
/* For Webkit browsers (Chrome, Safari, Edge) */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}
::-webkit-scrollbar-track {
    background: var(--scrollbar-track);
    border-radius: 4px;
}
::-webkit-scrollbar-thumb {
    background: var(--scrollbar-thumb);
    border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
    background: var(--scrollbar-thumb-hover);
}

/* For Firefox */
* {
    scrollbar-width: thin;
    scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
}

/* Apply to specific elements if needed */
.messages, .sidebar, .recent-chats-list, .search-results, .chat-search-results, .section-content, .admin-tab-content {
    scrollbar-width: thin;
    scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
}

/* ==================== MOBILE RESPONSIVENESS ==================== */
@media (max-width: 768px) {
    .sidebar { 
        width: 200px; 
    }
    .user-avatar { 
        display: none; 
    }
    .app-branding { 
        display: none; 
    }
}

@media (max-width: 480px) {
    .app-main { 
        flex-direction: column; 
    }
    
    .mobile-menu-toggle {
        display: flex;
        justify-content: center;
        align-items: center;
        position: fixed;
        top: 15px;
        right: 15px; /* Changed from left to right */
        left: auto;   /* Reset left property */
        z-index: 1001;
        background-color: var(--primary-color);
        color: var(--background-primary);
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 24px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .mobile-menu-toggle:hover { 
        background-color: var(--primary-hover); 
    }

    /* Keep sidebar exactly as it was */
    .sidebar {
        position: fixed;
        top: 0;
        left: 0;
        height: 100vh;
        width: 280px;
        z-index: 1000;
        transform: translateX(-100%);
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
    }
    
    .sidebar.open {
        transform: translateX(0);
    }
    
    .chat-area {
        width: 100%;
        margin-left: 0;
    }
    
    .message { 
        max-width: 90%; 
    }
    
    .section-header { 
        padding: 12px 15px; 
    }
    
    .section-header h3 { 
        font-size: 14px; 
    }
    
    .recent-chats-list, .room-list, .user-list { 
        padding: 0 15px 10px; 
    }
    
    .user-name, .logout-btn { 
        align-content: right-side; 
        margin-right: 5px; 
    }
}      here is the index.html:<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>aa-whisper</title>
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="app-container">
        <!-- ====================================================== -->
        <!-- AUTHENTICATION SECTION -->
        <!-- ====================================================== -->
        <section class="auth-container" id="auth-container">
            <div class="auth-form">
                <div class="app-logo">
                    <h1>aa-whisper.</h1>
                    <p>private messaging and calling client.</p>
                </div>
                <div class="auth-tabs">
                    <button class="auth-tab active" id="account-tab">account login</button>
                    <button class="auth-tab" id="guest-tab">join as guest</button>
                </div>
                
                <!-- Guest Login Form -->
                <div class="auth-panel" id="guest-panel">
                    <div class="disabled-overlay">
                        <h3>uest login disabled</h3>
                        <p>u gotta make an account to join the chat, mate.</p>
                    </div>
                    <h2>jump in.</h2>
                    <p>ur info will not be saved after sign-out.</p>
                    <div class="input-with-button">
                        <input type="text" id="guest-username" placeholder="display name" maxlength="20">
                        <button id="guest-login-btn">join</button>
                    </div>
                </div>
                
                <!-- Account Login Form -->
                <div class="auth-panel active" id="account-panel">
                    <h2>welcome back.</h2>
                    <input type="email" id="email" placeholder="email">
                    <div class="input-with-button">
                        <input type="password" id="password" placeholder="password">
                        <button id="login-btn">login</button>
                    </div>
                    <p class="auth-switch">don't have an account? <a href="#" id="show-signup">sign up.</a></p>
                    <p class="auth-switch">forgot ur password? <a href="#" id="reset-password-btn">reset it.</a></p>
                </div>
                
                <!-- Sign Up Form -->
                <div class="auth-panel" id="signup-panel">
                    <h2>welcome.</h2>
                    <input type="email" id="signup-email" placeholder="email">
                    <div class="input-with-button">
                        <input type="password" id="signup-password" placeholder="password (must be 6+ characters)">
                    </div>
                    <div class="input-with-button">
                        <input type="text" id="display-name" placeholder="display name">
                        <button id="signup-btn">sign up</button>
                    </div>
                    <p class="auth-switch">already have an account? <a href="#" id="show-login">log in.</a></p>
                </div>
                
                <!-- Set Username Form -->
                <div class="auth-panel" id="username-panel">
                    <h3>choose your username.</h3>
                    <p>this is how others will see you in chat.</p>
                    <input type="text" id="choose-username" placeholder="display name" maxlength="20">
                    <button id="set-username-btn">go</button>
                </div>
            </div>
        </section>
        
        <!-- ====================================================== -->
        <!-- MAIN APP SECTION -->
        <!-- ====================================================== -->
        <section class="app-main" id="app-main" style="display: none;">
            
            <!-- Mobile Menu Toggle -->
            <button class="mobile-menu-toggle" id="mobile-menu-toggle">‚ò∞</button>
            
            <!-- Sidebar -->
            <aside class="sidebar" id="sidebar">
                <!-- User Profile Section -->
                <div class="user-profile">
                    <div class="user-avatar" id="user-avatar"></div>
                    <div class="user-info">
                        <div class="user-name-container">
                            <div class="user-name" id="user-name"></div>
                            <!-- Email Verification Icon -->
                            <div class="email-verification-icon" id="email-verification-icon" style="display: none;" title="Email verification status">
                                <span class="verification-icon" id="verification-icon">‚úì</span>
                                <div class="verification-tooltip" id="verification-tooltip">
                                    <div class="tooltip-content">
                                        <span id="tooltip-status">verified</span>
                                        <div id="tooltip-email" class="tooltip-email"></div>
                                        <button id="verify-email-btn" class="tooltip-btn" style="display: none;">verify email</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="auth-actions">
                            <button id="logout-btn" class="logout-btn">get out</button>
                        </div>
                    </div>
                </div>
                
                <!-- Public Rooms Section -->
                <div class="rooms-section collapsible-section" id="rooms-section">
                    <div class="section-header">
                        <h3>public chats</h3>
                        <div class="section-controls">
                            <div id="add-room-container" style="display: none;">
                                <button id="open-new-room-modal-btn" class="refresh-btn">+</button>
                            </div>
                            <button class="collapse-toggle" data-section="rooms-section">‚ñº</button>
                        </div>
                    </div>
                    <div class="section-content" id="rooms-content">
                        <div class="room-list" id="room-list">
                            <div class="room-item active" data-room="general">General</div>
                            <div class="room-item" data-room="random">Random</div>
                        </div>
                    </div>
                </div>
                
                <!-- Private Chats Section -->
                <div class="recent-chats-section collapsible-section" id="recent-chats-section">
                    <div class="section-header">
                        <h3>humans</h3>
                        <div class="section-controls">
                            <button class="collapse-toggle" data-section="recent-chats-section">‚ñº</button>
                        </div>
                    </div>
                    <div class="section-content" id="recent-chats-content">
                        <div class="chat-search-results" id="chat-search-results"></div>
                        <div class="recent-chats-list" id="recent-chats-list"></div>
                    </div>
                </div>

                <!-- Admin Controls Section -->
                <div class="admin-section collapsible-section" id="admin-section" style="display: none;">
                    <div class="section-header">
                        <h3>admin controls</h3>
                        <button class="collapse-toggle" data-section="admin-section">‚ñº</button>
                    </div>
                    <div class="section-content" id="admin-content">
                        <div class="admin-controls">
                            <!-- User selector -->
                            <div class="admin-user-select-wrapper">
								<h4>select user:</h4>
                                <div class="admin-select-container">
                                    <select id="admin-user-select">
                                        <!-- Options will be populated by JavaScript -->
                                    </select>
                                    <button id="refresh-admin-users-btn" class="refresh-btn" title="Refresh user list">
                                        ‚Üª
                                    </button>
                                </div>
                            </div>
                            
                            <div class="admin-user-info" id="admin-user-info" style="display: none;">
                                <h4>info</h4>
                                <div class="user-info-grid">
                                    <div class="info-item"><span class="info-label">name:</span><span id="info-display-name">-</span></div>
                                    <div class="info-item"><span class="info-label">type:</span><span id="info-user-type">-</span></div>
                                    <div class="info-item"><span class="info-label">status:</span><span id="info-status">-</span></div>
                                    <div class="info-item"><span class="info-label">last seen:</span><span id="info-last-seen">-</span></div>
                                </div>
                            </div>
                            
                            <div class="admin-form-group">
                                <label for="admin-reason-input">reason (required for banning):</label>
                                <textarea id="admin-reason-input" class="admin-textarea" placeholder="reason for action..."></textarea>
                            </div>
							
							<h4>options:</h4>
                            
                            <div class="admin-buttons">
                                <button id="ban-user-btn" class="admin-button ban-button admin-only">ban</button>
                                <button id="unban-user-btn" class="admin-button unban-button admin-only">unban</button>
                            </div>
                            
                            <div class="leader-buttons">
                                <button id="grant-admin-btn" class="admin-button grant-button leader-only">grant admin</button>
                                <button id="revoke-admin-btn" class="admin-button revoke-button leader-only">revoke admin</button>
                            </div>
                            
                            <div id="admin-action-message" class="admin-notification" style="display: none;"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Sidebar Footer -->
                <div class="sidebar-footer">
                    <p>made by <a href="https://sites.google.com/view/aa-infinitech/" target="_blank">aa</a> and adyan using ai</p>
                    <a href="https://aa-whisper.netlify.app/help" target="_blank">need help?</a>
                </div>
            </aside>
            
            <!-- Chat Area -->
            <main class="chat-area">
                <!-- Chat Header -->
                <div class="chat-header">
                    <div class="header-left">
                        <h2 id="current-room-name">General</h2>
                    </div>
                    <span class="app-branding">aa-whisper.</span>
                </div>
                
                <!-- Banned notification -->
                <div id="banned-notification" class="banned-notification" style="display: none;">
                    <div class="banned-content">
                        <div class="banned-icon">üö´</div>
                        <div class="banned-message">
                            <h3>ur banned from messaging, man.</h3>
                            <p id="ban-reason-text">reason: no reason provided</p>
                            <p>fix up.</p>
                        </div>
                    </div>
                </div>

                <!-- Messages Container -->
                <div class="messages" id="messages">
                    <div class="messages-loading-container" id="messages-loading-container" style="display: none;">
                        <div class="loading-spinner-large"></div>
                    </div>
                </div>
                
				<!-- Message Input -->
				<div class="message-input" id="message-input-container">
					<div class="message-input-typing" id="typing-indicator"></div>
					<div class="input-with-button">
						<input type="text" id="message-input" placeholder="start typing..." maxlength="200" autofocus>
						<button id="send-btn">‚ñ∂Ô∏è</button>
					</div>
				</div>
            </main>
        </section>
    </div>

    <!-- Modals -->
    <div id="new-chat-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>find users</h3>
                <button class="close-modal" id="close-modal-btn">&times;</button>
            </div>
            <div class="search-results" id="search-results"></div>
        </div>
    </div>
    
    <div id="new-room-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>open a room</h3>
                <button class="close-modal" id="close-new-room-modal-btn">&times;</button>
            </div>
            <input type="text" id="new-room-name-modal" class="search-user-input" placeholder="enter new room name...">
            <div id="new-room-error-message" class="error-message" style="display: none;"></div>
        </div>
    </div>
	
	<div id="call-modal" class="modal">
		<div class="modal-content call-modal-content">
			<!-- This will be populated by JavaScript -->
		</div>
	</div>

    <div id="admin-confirm-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="confirm-title">u sure?</h3>
                <button class="close-modal" id="confirm-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <p id="confirm-message">u sure u wanna do this?</p>
                <div id="confirm-details" class="confirm-details"></div>
            </div>
            <div class="modal-footer">
                <button id="confirm-cancel-btn" class="btn btn-secondary">cancel</button>
                <button id="confirm-ok-btn" class="btn btn-danger">confirm</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>
    
    <!-- Your app script -->
    <script src="app.js?v=2"></script>
    
    <!-- Custom Notification Container -->
    <div id="notification-container" class="notification-container"></div>
	
	<!-- Sound effects -->
	<audio id="notification-sound" src="new_message.mp3" preload="auto"></audio>

</body>

</html>
and dont get confused but in the app there is a thing in the bottom left were u click help and this is page it should take u to <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>aa-whisper help and changes</title>
    <style>
        body {
			font-family: 'Consolas', 'Aptos Mono', 'Monaco', 'Cascadia Code', monospace;
            background: linear-gradient(135deg, #1a1a2e, #32264a);
            color: #fff;
            display: flex;
			border-radius: 10px;			
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            text-align: center;
        }

        .info-box {
            background: linear-gradient(300deg, #2e2e2e, #1e1e1e);
            padding: 40px;
            border: 2px solid #cf6679
			border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            max-width: 600px;
        }

        .icon {
            font-size: 54px;
			font-weight: 800;
            color: #bb87fc;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2em;
			font-weight: 500;
            margin-bottom: 15px;
			color: #bb86fc
        }

        p {
            font-size: 1.1em;
			font-weight: 400;
            line-height: 1.5;
        }
    </style>
</head>
<body>

    <div class="info-box">
        <div class="icon">welcome to whisper.</div>
        <h1>need help?</h1>
        <p>messages don't load after logging in? click on the chat in the sidebar to force-load it.</p>
		<p>login form doesn't appear after logging out? refresh the page.</p>
		<p>calling doesn't work? make sure u have a mic and/or camera plugged in and allow permissions.</p>p>
		<p>- - -</p>
		<p>found issues or want to recommend something? message me privately (aathehuman).</p>
    </div>

</body>

</html> please fix calll add a new tab for call make video call and please add screen sharing  give me whole code
